
from colorama import Fore, Back
from colorama import init, deinit, reinit
init()
import os
import time
import random
import math
from playsound import playsound
from pygame import mixer
os.system("cls")
mixer.init()
import requests
from stat import S_IREAD, S_IRGRP, S_IROTH,  S_IROTH, S_IWUSR
import datetime
import ctypes
import threading
from threading import Thread
kernel32 = ctypes.windll.kernel32
kernel32.SetConsoleMode(kernel32.GetStdHandle(-10), 128)
import msvcrt
import keyboard
import winsound
import numpy as np

#cd D:/Python & D: & python Замки.py



# Значения до игры
def Очистка_Буфера():
	while msvcrt.kbhit():
		msvcrt.getch()

Игра_против_ИИ = True
Координата_катапульты_ии = 0 # Определят куда будет стрелять ии
Снаряд_ИИ = [0, 0, 0]
Номер_война_ии = 0
Point = 500
medium = 1

Цвет_флага_Л = "G"
Цвет_флага_П = "C"



################################################################# Замки

# Звуки
Путь = "D:/Python/Обнова 1.6/Звуки и музыка/Звуки/Тиканье часов/"
def Звук_TIK1():
	winsound.PlaySound(Путь+"TIK1.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_TIK2():
	winsound.PlaySound(Путь+"TIK2.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Example():
	winsound.PlaySound(Путь+"Example.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Заморозки():
	winsound.PlaySound(Путь+"Zamorog.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Kill():
	winsound.PlaySound(Путь+"Kill.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Fire():
	winsound.PlaySound(Путь+"Fire.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Выстрел():
	winsound.PlaySound(Путь+"vistrel.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_hod():
	winsound.PlaySound(Путь+"hod.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_разбил_лед():
	winsound.PlaySound(Путь+"Razbil_Led.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_в_стену(x):
	if x == 1:
		winsound.PlaySound(Путь+"V_steny1.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
	elif x == 2:
		winsound.PlaySound(Путь+"V_steny2.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
	elif x == 3:
		winsound.PlaySound(Путь+"V_steny3.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Камень():
	winsound.PlaySound(Путь+"kamen.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_ничья():
	winsound.PlaySound(Путь+"otraz.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Урон():
	winsound.PlaySound(Путь+"damage.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Oui():
	winsound.PlaySound(Путь+"Oui.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_NePa():
	winsound.PlaySound(Путь+"Ne_pa.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_build():
	winsound.PlaySound(Путь+"build.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_U():
	winsound.PlaySound(Путь+"Spawn_U.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_skip():
	winsound.PlaySound(Путь+"skip.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_heal():
	winsound.PlaySound(Путь+"heal.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_kush():
	winsound.PlaySound(Путь+"kush.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)
def Звук_Bonus():
	winsound.PlaySound(Путь+"Bonus.wav", winsound.SND_ASYNC | winsound.SND_FILENAME)

def Think():
	global Think_n, Mus

	if Mus != "Think":
		Mus = "Think"
		Think_new = Think_n
		while Think_new == Think_n:
			Think_new = random.randint(1, 7)
		Think_n = Think_new

		mixer.music.load("D:/Python/Обнова 1.6/Звуки и музыка/Музыка/Обработанное/Think_" + str(Think_n) + ".mp3")
		mixer.music.play()

def Make():
	global Make_n, Mus

	if Mus != "Make":
		Mus = "Make"
		Make_new = Make_n
		while Make_new == Make_n:
			Make_new = random.randint(1, 11)
		Make_n = Make_new

		mixer.music.load("D:/Python/Обнова 1.6/Звуки и музыка/Музыка/Обработанное/Make_" + str(Make_n) + ".mp3")
		mixer.music.play()




Example = 0 # Переменная для звука

Think_n = 1 # Музыка для примеров
Make_n = 1  # Музыка для выбора

Mus = "Make"



deinit()
os.system("color 70")
os.system("mode con:cols=119 lines=30")

'''
# - стены замка
U - баф
m - Монетка
S - Снаряд катапульты

W - Белый   (Запрещен для флага)
B - Синий   (Запрещен для флага)
C - Голубой
Y - Желтый 
G - Зеленый 
M - Фиолетовый
R - Красный (Запрещен для флага)
'''

# Определяем сложность

сложность = 1 # 0 , 1

Win_L = None # True - Если победил левый, False - Если правый

# Через какое кол-во ходов станет доступен пункт
Перезарядка_пунктов_L = [[0,0,0,0], [0,0,0], [0,0]]
Перезарядка_пунктов_R = [[0,0,0,0], [0,0,0], [0,0]]

# Образцы
Образец_война_легкая_пехота_L = [4,466,"Norm","None",3,2,0,0,"Mag"]
Образец_война_легкая_пехота_R = [4,477,"Norm","None",3,2,0,0,"Mag"]

Образец_война_тяжелая_пехота_L = [7,466,"Norm","None",2,4,0,0,"Powerful"]
Образец_война_тяжелая_пехота_R = [7,477,"Norm","None",2,4,0,0,"Powerful"]

# Подготовка всех переменных
Ветер_Направо = None # Положение ветра, если True, значит дует вправо, если False, значит влево
if random.randint(0,1) == 1:
	Ветер_Направо = True
else:
	Ветер_Направо = False

Смена_ветра = random.randint(2,6) # Через сколько ходов сменится ветер
Новый_Баф = random.randint(10, 15) # Через сколько ходов на поле появится баф, Баф падает на поле 1 раз через каждые 10-15 ходов

Л_Катапульта = False # False - Катапульта в сложенном положении и готова для выстрела # True - находится в моменте стрельбы
П_Катапульта = False

Решение_примера = True # True - показываем решение примера, False - Даем выбор
Пример_сейчас = [] # Хранит a,b,x,znak
Разброс_ответа = []
Создание_примера = True

Перемещение_в_меню = 0 # Переменая для меню
Global_Выбор = 0 # Переменая для меню

Монеты_Л = 0 # Очки за решенные примеры
Монеты_П = 0

Баф_Л = [0, 0] # Бафы собранные на поле (0 означает через сколько ходов закончится баф)
Баф_П = [0, 0] # Переменные для хранения временных бафов и их срока действия


Разрушенные_Клетки_Л = [] # Хранит координаты упавших блоков
Разрушенные_Клетки_П = []

Войны_Л = [] # Хранит объекты (Войнов) на поле
Войны_П = []

Хп_Л = Point
Хп_П = Point

TIME_Z = 6 # Таймер

Ход = 1

# Выбор игрока
INPUT = ""

# Переменная для попадания в замки через катапульту, Fasle - если попадают в правый замок, True - если в левый
Левый_З = False

# Если ходит левый, то True, если правый - False
Ходит_Л = None

# Определяем кто ходит первый
if random.randint(0,1) == 1:
	Ходит_Л = True
else:
	Ходит_Л = False



# Пременная для обновления кадров 1 FPS
Секунда_Сейчас_ЗАМКИ = int(datetime.datetime.today().strftime("%S"))


# Выводит информацию о игре
Чат = ""

#C - Голубой
#Y - Желтый 
#G - Зеленый 
#M - Фиолетовый

# Для глобального чата
Назавние_левой_команды = ""
Назавние_правой_команды = ""

if Цвет_флага_Л == "C":
	Назавние_левой_команды = Back.CYAN+Fore.BLACK+"синего флага"+Fore.BLACK+Back.WHITE
	L_color = Back.CYAN+Fore.BLACK
elif Цвет_флага_Л == "Y":
	Назавние_левой_команды = Back.YELLOW+Fore.BLACK+"желтого флага"+Fore.BLACK+Back.WHITE
	L_color = Back.YELLOW+Fore.BLACK
elif Цвет_флага_Л == "G":
	Назавние_левой_команды = Back.GREEN+Fore.BLACK+"зеленого флага"+Fore.BLACK+Back.WHITE
	L_color = Back.GREEN+Fore.BLACK
elif Цвет_флага_Л == "M":
	Назавние_левой_команды = Back.MAGENTA+Fore.RESET+"фиолетового флага"+Fore.BLACK+Back.WHITE
	L_color = Back.MAGENTA+Fore.RESET

if Цвет_флага_П == "C":
	Назавние_правой_команды = Back.CYAN+Fore.BLACK+"синего флага"+Fore.BLACK+Back.WHITE
	R_color = Back.CYAN+Fore.BLACK
elif Цвет_флага_П == "Y":
	Назавние_правой_команды = Back.YELLOW+Fore.BLACK+"желтого флага"+Fore.BLACK+Back.WHITE
	R_color = Back.YELLOW+Fore.BLACK
elif Цвет_флага_П == "G":
	Назавние_правой_команды = Back.GREEN+Fore.BLACK+"зеленого флага"+Fore.BLACK+Back.WHITE
	R_color = Back.GREEN+Fore.BLACK
elif Цвет_флага_П == "M":
	Назавние_правой_команды = Back.MAGENTA+Fore.RESET+"фиолетового флага"+Fore.BLACK+Back.WHITE
	R_color = Back.MAGENTA+Fore.RESET

# Образцы
Множитель_урона_для_крепости_Л = 10 # На сколько увеличивать урон когда атакуешь крепость
Множитель_урона_для_крепости_П = 10



# Подготовка функций

def print_zamok():
	os.system("cls")
	# Выводим изображение
	for i in range(len(Игровое_поле)):
		if i not in OTSTYP:
			if Игровое_поле[i] == " ":
				print(Игровое_поле[i],end="")
			elif Игровое_поле[i] == "#":
				print(Back.RESET+Fore.BLACK+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "M":
				print(Back.MAGENTA+Fore.MAGENTA+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "Y":
				print(Back.YELLOW+Fore.YELLOW+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "R":
				print(Back.RED+Fore.RED+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "B":
				print(Back.BLUE+Fore.BLUE+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "C":
				print(Back.CYAN+Fore.CYAN+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "G":
				print(Back.GREEN+Fore.GREEN+Игровое_поле[i]+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i] == "U":
				print(Back.MAGENTA+Fore.WHITE+"?"+Back.WHITE+Fore.BLACK,end="")
			elif type(Игровое_поле[i]) == int:
				if Игровое_поле[i] == 0:
					print(Back.BLACK+Fore.BLUE+str(Игровое_поле[i])+Back.WHITE+Fore.BLACK,end="")
				elif Игровое_поле[i] < 4:
					print(Back.BLACK+Fore.RED+str(Игровое_поле[i])+Back.WHITE+Fore.BLACK,end="")
				elif Игровое_поле[i] < 6:
					print(Back.BLACK+Fore.YELLOW+str(Игровое_поле[i])+Back.WHITE+Fore.BLACK,end="")
				else:
					print(Back.BLACK+Fore.GREEN+str(Игровое_поле[i])+Back.WHITE+Fore.BLACK,end="")
			elif Игровое_поле[i][:3] == "num":
				num = Игровое_поле[i][-1]
				print(Back.BLACK+Fore.RESET+str(num)+Back.WHITE+Fore.BLACK,end="")

				
		else:
			print("\n"+39*" ",end="")


	Цвет_хп_Л_Temp = Back.RESET+Fore.RESET
	Цвет_хп_П_Temp = Back.RESET+Fore.RESET

	# Для левого
	if Процент_от_числа_int(Хп_Л,Point) >= 70:
		Цвет_хп_Л_Temp = Back.GREEN+Fore.BLACK
	elif Процент_от_числа_int(Хп_Л,Point) >= 40:
		Цвет_хп_Л_Temp = Back.YELLOW+Fore.BLACK
	elif Процент_от_числа_int(Хп_Л,Point) >= 20:
		Цвет_хп_Л_Temp = Back.RED+Fore.WHITE	
	elif Процент_от_числа_int(Хп_Л,Point) >= 0:
		Цвет_хп_Л_Temp = Back.RESET+Fore.RESET
	# Для правого
	if Процент_от_числа_int(Хп_П,Point) >= 70:
		Цвет_хп_П_Temp = Back.GREEN+Fore.BLACK
	elif Процент_от_числа_int(Хп_П,Point) >= 40:
		Цвет_хп_П_Temp = Back.YELLOW+Fore.BLACK
	elif Процент_от_числа_int(Хп_П,Point) >= 20:
		Цвет_хп_П_Temp = Back.RED+Fore.WHITE	
	elif Процент_от_числа_int(Хп_П,Point) >= 0:
		Цвет_хп_П_Temp = Back.RESET+Fore.RESET



	print(2*"\n"+39*" "+Цвет_хп_Л_Temp+str(Хп_Л)+"/"+str(Point) + Fore.BLACK + Back.WHITE + (40 - (2*len(str(Point))+2+len(str(Хп_Л))+len(str(Хп_П))) )*" " + Цвет_хп_П_Temp+str(Хп_П)+"/"+str(Point)+Fore.BLACK+Back.WHITE)
	print("\n"+39*" "+"> "+Чат)

def Катапульты_хитбоксы():
	# Применять после выстрела катапульт

	# Очищаем катапульты
	# Левая
	Игровое_поле[379] = " "
	Игровое_поле[419] = " "
	Игровое_поле[339] = " "
	Игровое_поле[299] = " "
	# Правая
	Игровое_поле[400] = " "
	Игровое_поле[442] = " "
	Игровое_поле[358] = " "
	Игровое_поле[316] = " "
	# Рисуем хитбоксы
	if Л_Катапульта:
		Игровое_поле[339] = "#"
		Игровое_поле[299] = "#"
	else:
		Игровое_поле[379] = "#"
		Игровое_поле[419] = Снаряд_L.skin
		

	if П_Катапульта:
		Игровое_поле[358] = "#"
		Игровое_поле[316] = "#"
	else:
		Игровое_поле[400] = "#"
		Игровое_поле[442] = Снаряд_R.skin
		

def Флаги_хитбоксы():
	# Применять после смены ветра и после выстрела катапульты

	# Очистка

	# Левый флаг
	#	Ветер вправо
	Игровое_поле[50] = " "
	Игровое_поле[49] = " "
	Игровое_поле[48] = " "
	Игровое_поле[47] = " "

	Игровое_поле[90] = " "
	Игровое_поле[89] = " "
	Игровое_поле[88] = " "
	#	Ветер влево
	Игровое_поле[45] = " "
	Игровое_поле[44] = " "
	Игровое_поле[43] = " "
	Игровое_поле[42] = " "

	Игровое_поле[86] = " "
	Игровое_поле[85] = " "
	Игровое_поле[84] = " "

	# Правый флаг
	#	Ветер влево
	Игровое_поле[76] = " "
	Игровое_поле[75] = " "
	Игровое_поле[74] = " "
	Игровое_поле[73] = " "

	Игровое_поле[117] = " "
	Игровое_поле[116] = " "
	Игровое_поле[115] = " "
	#	Ветер вправо
	Игровое_поле[81] = " "
	Игровое_поле[80] = " "
	Игровое_поле[79] = " "
	Игровое_поле[78] = " "

	Игровое_поле[121] = " "
	Игровое_поле[120] = " "
	Игровое_поле[119] = " "


	if Ветер_Направо:
		# Левый замок
		if Игровое_поле[46] == "#":
			Игровое_поле[50] = Цвет_флага_Л
			Игровое_поле[49] = Цвет_флага_Л
			Игровое_поле[48] = Цвет_флага_Л
			Игровое_поле[47] = Цвет_флага_Л

		if Игровое_поле[87] == "#":
			if random.randint(0,1) == 1:
				Игровое_поле[90] = Цвет_флага_Л
			Игровое_поле[89] = Цвет_флага_Л
			Игровое_поле[88] = Цвет_флага_Л

		# Правый замок
		if Игровое_поле[77] == "#":
			Игровое_поле[81] = Цвет_флага_П
			Игровое_поле[80] = Цвет_флага_П
			Игровое_поле[79] = Цвет_флага_П
			Игровое_поле[78] = Цвет_флага_П

		if Игровое_поле[118] == "#":
			if random.randint(0,1) == 1:
				Игровое_поле[121] = Цвет_флага_П
			Игровое_поле[120] = Цвет_флага_П
			Игровое_поле[119] = Цвет_флага_П

		
	else:
		# Левый замок
		if Игровое_поле[46] == "#":
			Игровое_поле[45] = Цвет_флага_Л
			Игровое_поле[44] = Цвет_флага_Л
			Игровое_поле[43] = Цвет_флага_Л
			Игровое_поле[42] = Цвет_флага_Л

		if Игровое_поле[87] == "#":
			Игровое_поле[86] = Цвет_флага_Л
			Игровое_поле[85] = Цвет_флага_Л
			if random.randint(0,1) == 1:
				Игровое_поле[84] = Цвет_флага_Л

		# Правый замок
		if Игровое_поле[77] == "#":
			Игровое_поле[76] = Цвет_флага_П
			Игровое_поле[75] = Цвет_флага_П
			Игровое_поле[74] = Цвет_флага_П
			Игровое_поле[73] = Цвет_флага_П

		if Игровое_поле[118] == "#":
			Игровое_поле[117] = Цвет_флага_П
			Игровое_поле[116] = Цвет_флага_П
			if random.randint(0,1) == 1:
				Игровое_поле[115] = Цвет_флага_П

def Развивание_флагов():
	# Применять каждый ход

	if Ветер_Направо:
		if Игровое_поле[87] == "#":
			if random.randint(0,1) == 1:
				Игровое_поле[90] = Цвет_флага_Л
			else:
				Игровое_поле[90] = " "

		if Игровое_поле[118] == "#":
			if random.randint(0,1) == 1:
				Игровое_поле[121] = Цвет_флага_П
			else:
				Игровое_поле[121] = " "

	else:
		if Игровое_поле[87] == "#":
			if random.randint(0,1) == 1:
				Игровое_поле[84] = Цвет_флага_Л
			else:
				Игровое_поле[84] = " "

		if Игровое_поле[118] == "#":	
			if random.randint(0,1) == 1:
				Игровое_поле[115] = Цвет_флага_П
			else:
				Игровое_поле[115] = " "

def Починить_замок(Замок):
	# Возвращает замкам преждний вид
	
	# Необходимые глобальные переменные
	global Разрушенные_Клетки_Л, Разрушенные_Клетки_П, Игровое_поле, Чат, Хп_Л, Хп_П

	# Добавляем 120 хп
	if Замок == "L":
		Хп_Л += 70
		if Хп_Л > Point:
			Хп_Л = Point
	elif Замок == "R":
		Хп_П += 70
		if Хп_П > Point:
			Хп_П = Point

	Звук_build()

	# Убираем все разрушенное
	if Замок == "L":
		for i in range(len(Разрушенные_Клетки_Л)):
			Игровое_поле[Разрушенные_Клетки_Л[i]] = " "
		Разрушенные_Клетки_Л.clear()
		# Дополнительная очистка
		Игровое_поле[459] = " "
		Игровое_поле[417] = " "
	elif Замок == "R":
		for i in range(len(Разрушенные_Клетки_П)):
			Игровое_поле[Разрушенные_Клетки_П[i]] = " "
		Разрушенные_Клетки_П.clear()
		# Дополнительная очистка
		Игровое_поле[484] = " "
		Игровое_поле[444] = " "
	

	Temp = []
	# Возвращаем черные пиксели
	if Замок == "L":
		Temp = Координаты_Замков[8:42]
	elif Замок == "R":
		Temp = Координаты_Замков[42:]

	for i in range(len(Temp)):
		Игровое_поле[Temp[i]] = "#"

	# Возвращаем фиолетовые пиксели
	Temp = []

	if Замок == "L":
		Temp = FIOLET[:12]
	elif Замок == "R":
		Temp = FIOLET[12:]

	for i in range(len(Temp)):
		Игровое_поле[Temp[i]] = "M"

	# На всякий случай восстанавливаем флаги
	Флаги_хитбоксы()

	# Сообщение о починке замков

	if Замок == "L":
		Чат = "Левый замок восстановлен"
	elif Замок == "R": 
		Чат = "Правый замок восстановлен"

	
	

def Физика_разрушения(Coord, Левый_З):
	#Разрушает блок на координате Coord и опускает все остальные блоки до ближайшей земли заполняя списки разрушенных блоков

	global Разрушенные_Клетки_Л, Разрушенные_Клетки_П
	Разрушенные_Клетки_Л_temp = []
	Разрушенные_Клетки_П_temp = []

	# Очищаем клетку, вставленную в функцию
	if Игровое_поле[Coord] != " ":
		Звук_в_стену(random.randint(1, 2))
	TIME = 0.1
	print_zamok()
	time.sleep(TIME)
	Игровое_поле[Coord] = " "
	print_zamok()
	time.sleep(TIME)

	# Считаем кол-во объектов сверху и добавляем их в список разрушенных объектов
	i = Coord
	cout = 0
	while True:
		if Игровое_поле[i - 41] == "#" or Игровое_поле[i - 41] == "M":	
			if Левый_З:
				Разрушенные_Клетки_Л.append(i-41)
				Разрушенные_Клетки_Л_temp.append(i-41)
			else:
				Разрушенные_Клетки_П.append(i-41)
				Разрушенные_Клетки_П_temp.append(i-41)
			cout += 1
		elif Игровое_поле[i - 41] == " ":
			break
		i -= 41

	# Считаем рассояние до земли S
	Расстояние_до_земли = 1
	i = Coord

	while True:
		i += 41
		if Игровое_поле[i] == "#" or Игровое_поле[i] == "M":
			break
		else:
			Расстояние_до_земли += 1

	
	def Падение_блоков(Левый_З,SPISOK):
		
		# Цикл равный времени и растоянию падения
		for i in range(Расстояние_до_земли): # +1 т.к счиаем от разрушенного блока
			
			# Опускаем все блоки, кот находятся в списке на 1 клетку вниз
			SPISOK = list(map(lambda x: x + 41, (SPISOK)))

			for j in range(len(SPISOK)):
				Игровое_поле[SPISOK[j]] = Игровое_поле[SPISOK[j]-41]

			# Подчищаем хвотст
			Игровое_поле[SPISOK[-1]-41] = " "

			# Проверяем наличие флагов и выводим изображение
			Флаги_хитбоксы()
			print_zamok()
			time.sleep(TIME)
			

		# Возвращаем список разрушенных блоков
		SPISOK = list(map(lambda x: x - 41, (SPISOK)))
		return SPISOK
			
			
	# Перемещаем все это добро вниз
	if cout != 0:
		if Левый_З:
			Разрушенные_Клетки_Л += Падение_блоков(Левый_З,Разрушенные_Клетки_Л_temp)
		else:
			Разрушенные_Клетки_П += Падение_блоков(Левый_З,Разрушенные_Клетки_П_temp)
		Звук_в_стену(3)
		time.sleep(0.2)

	Флаги_хитбоксы()
	Устойчивость_Замков()

def Устойчивость_Замков():
	# Разрушает блоки без опоры
	# Функция "Флаги_хитбоксы()" не нужна, тк отслеживаются только кончики замков

	# Чек RIGHT
	if Игровое_поле[363] == " " and Игровое_поле[362] != " ":
		Физика_разрушения(362,False)
	if Игровое_поле[321] == " " and Игровое_поле[320] != " ":
		Физика_разрушения(361,False)

	# Чек LEFT
	if Игровое_поле[334] == " " and Игровое_поле[335] != " ":
		Физика_разрушения(335,True)
	if Игровое_поле[294] == " " and Игровое_поле[295] != " ":
		Физика_разрушения(336,True)
	
	


def Войны_Хитбоксы():
	# Добавляем координаты солдат на Игровое поле

	for i in range(len(Войны_Л)):
		# Скин обычного солдата
		if Войны_Л[i].hp > 0:
			if Войны_Л[i].status == "Norm":
				Игровое_поле[Войны_Л[i].coord] = Цвет_флага_Л
				Игровое_поле[Войны_Л[i].coord - 41] = "#"
				Игровое_поле[Войны_Л[i].coord + 41] = Войны_Л[i].hp
			# Скин замороженного солдата
			elif Войны_Л[i].status == "Freeze":
				Игровое_поле[Войны_Л[i].coord] = "B"
				Игровое_поле[Войны_Л[i].coord - 41] = "B"
				Игровое_поле[Войны_Л[i].coord + 41] = 0
			# Скин подоженного солдата	
			elif Войны_Л[i].status == "Fire":
				Игровое_поле[Войны_Л[i].coord] = "R"
				Игровое_поле[Войны_Л[i].coord - 41] = "R"
				Игровое_поле[Войны_Л[i].coord + 41] = Войны_Л[i].hp

	for i in range(len(Войны_П)):
		# Скин обычного солдата
		if Войны_П[i].hp > 0:
			if Войны_П[i].status == "Norm":
				Игровое_поле[Войны_П[i].coord] = Цвет_флага_П
				Игровое_поле[Войны_П[i].coord - 41] = "#"
				Игровое_поле[Войны_П[i].coord + 41] = Войны_П[i].hp
			# Скин замороженного солдата
			elif Войны_П[i].status == "Freeze":
				Игровое_поле[Войны_П[i].coord] = "B"
				Игровое_поле[Войны_П[i].coord - 41] = "B"
				Игровое_поле[Войны_П[i].coord + 41] = 0
			# Скин подоженного солдата	
			elif Войны_П[i].status == "Fire":
				Игровое_поле[Войны_П[i].coord] = "R"
				Игровое_поле[Войны_П[i].coord - 41] = "R"
				Игровое_поле[Войны_П[i].coord + 41] = Войны_П[i].hp


def Перемещение_и_атака_юнитов():
	# Использовать каждый ход
 
	global  Хп_П, Хп_Л, Чат, Win_L


	# Первым делом считаем статусы войнов
	Просчет_статусов_войнов()
	# Потом отчищаем войнов с отрицательными hp
	Очистка_Войнов()

	if Ходит_Л:
		Дефолт = Войны_Л
		#Дефолт = Очистка_Войнов(Дефолт)
		Инверсия = Войны_П
		Дефолт_num = 1 # В какую сторону перемещаемся
		Противник = Цвет_флага_П
		Союзник = Цвет_флага_Л
		Противник_замок = Хп_П
		Мой_замок = Хп_Л
		Назавние_команды = Назавние_левой_команды
		Сторона = "L"
		Множитель_урона_для_крепости = Множитель_урона_для_крепости_Л
		Мой_баф_юнит = Баф_Л
		От = len(Дефолт) - 1
		До = -1
		Шаг = -1
	else:
		Дефолт = Войны_П
		# Сразу отчищаем войнов с отрицательными hp
		#Дефолт = Очистка_Войнов(Дефолт)
		Инверсия = Войны_Л
		Дефолт_num = -1
		Противник = Цвет_флага_Л
		Союзник = Цвет_флага_П
		Противник_замок = Хп_Л
		Мой_замок = Хп_П
		Назавние_команды = Назавние_правой_команды
		Сторона = "R"
		Множитель_урона_для_крепости = Множитель_урона_для_крепости_П
		Мой_баф_юнит = Баф_П
		От = 0
		До = len(Дефолт)
		Шаг = 1

	# Если есть войны
	if len(Дефолт) != 0:
		print_zamok()
		time.sleep(1)

	# Если есть войны
	if len(Дефолт) != 0:

		Дефолт = Сортировка_войнов(Дефолт)

		# Перемещаем каждого война в обратном порядке
		for i in range(От, До, Шаг):

			# Двигаем на расстояние равное скорости война и останавливаем его.
			for j in range(Дефолт[i].V):

				# Проверяем может ли двигаться воин
				if Дефолт[i].status == "Freeze" or Дефолт[i].status == "Fire":
					break

				# Запоминаем координату, чтобы потом ее очистить
				Temp = Дефолт[i].coord

				# Экстренно останавливаем если далее есть преграда
				if Игровое_поле[Дефолт[i].coord + Дефолт_num] == " ":
					Дефолт[i].coord += Дефолт_num
					#
					Игровое_поле[Temp] = " "
					Игровое_поле[Temp + 41] = "#"
					Игровое_поле[Temp - 41] = " "
					Войны_Хитбоксы()
					Звук_hod()
					print_zamok()
					time.sleep(0.3)
					#
				else:
					# Проверяем конкретно во что он врезался

					# Если это противник
					if Игровое_поле[Дефолт[i].coord + Дефолт_num] == Противник:
						# Выясняем индекс противника из списка
						index = 0
						for k in range(len(Инверсия)):
							if Инверсия[k].coord == Дефолт[i].coord + Дефолт_num:
								index = k
								break

						Атака(Дефолт[i],Инверсия[index],Сторона)
						Войны_Хитбоксы()
						print_zamok()
						time.sleep(0.5)
						del index

						break
						
					# Если это союзник (Возможен обгон)
					elif Игровое_поле[Дефолт[i].coord + Дефолт_num] == Союзник:
						# Если осталась скорость
						if Дефолт[i].V != 1:
							# Если за союзником нет препятствий
							if j != Дефолт[i].V and Игровое_поле[Дефолт[i].coord + 2*(Дефолт_num)] == " ":

								# Выясняем индекс союзника из списка
								index = 0
								for k in range(len(Дефолт)):
									if Дефолт[k].coord == Дефолт[i].coord + Дефолт_num:
										index = k
										break

								# Перемещаем война на 2 единицы
								Дефолт[i].coord += Дефолт_num
								Дефолт[i].coord += Дефолт_num

								#
								Игровое_поле[Temp] = " "
								Игровое_поле[Temp + 41] = "#"
								Игровое_поле[Temp - 41] = " "
								Войны_Хитбоксы()
								Звук_hod()
								print_zamok()
								time.sleep(0.3)
								#

					# Если это замороженный воин		
					elif Игровое_поле[Дефолт[i].coord + Дефолт_num] == "B":
						# Если это противник
						if Поиск_война(Инверсия,Дефолт[i].coord + Дефолт_num, 1):
							
							# Удаляем противника
							Инверсия.remove(Поиск_война(Инверсия,Дефолт[i].coord + Дефолт_num, 0))

							# Отчищаем место, занимаемое атакующим войном
							Игровое_поле[Temp] = " "
							Игровое_поле[Temp + 41] = "#"
							Игровое_поле[Temp - 41] = " "

							# Двигаем атакующего на 1 клетку
							Дефолт[i].coord += Дефолт_num

							Войны_Хитбоксы()
							Звук_разбил_лед()
							print_zamok()
							time.sleep(0.5)

					# Если это воин под огнем
					elif Игровое_поле[Дефолт[i].coord + Дефолт_num] == "R":
						# Игровое правило: загораемся только от союзников

						# Если это союзник
						if Поиск_война(Дефолт,Дефолт[i].coord + Дефолт_num, 1):
							Дефолт[i].status = "Fire"
							Дефолт[i].i_status = Поиск_война(Дефолт,Дефолт[i].coord + Дефолт_num, 2).i_status

						elif Поиск_война(Инверсия,Дефолт[i].coord + Дефолт_num, 1):

							# Удаляем противника
							Инверсия.remove(Поиск_война(Инверсия,Дефолт[i].coord + Дефолт_num, 0))

							# Отчищаем место, занимаемое атакующим войном
							Игровое_поле[Temp] = " "
							Игровое_поле[Temp + 41] = "#"
							Игровое_поле[Temp - 41] = " "
							
							# Двигаем атакующего на 1 клетку
							Дефолт[i].coord += Дефолт_num


							Войны_Хитбоксы()
							Звук_Kill()
							print_zamok()
							time.sleep(0.5)

							#cd D:/Python & D: & python Замки.py

					# U
					elif Игровое_поле[Дефолт[i].coord + Дефолт_num] == "U":
						Дефолт[i].coord += Дефолт_num
						#
						Игровое_поле[Temp] = " "
						Игровое_поле[Temp + 41] = "#"
						Игровое_поле[Temp - 41] = " "
						Войны_Хитбоксы()
						Звук_hod()
						print_zamok()
						time.sleep(0.3)
						#
						Эффект_баф(Дефолт[i])


					# Если это замок противника
					elif Игровое_поле[Дефолт[i].coord + Дефолт_num] == "#":

						# Бонус "Уведичен множитель урона на крепость"
						Бонус_множитель = 2 if Мой_баф_юнит[1] == 4 and Мой_баф_юнит[0] > 0 else 1

						Противник_замок -= Дефолт[i].damage * Множитель_урона_для_крепости * Бонус_множитель

						# Бонус "Магические войны при штурме стен вражеского замка прибавляют отнимаемый урон в свой замок"
						if Мой_баф_юнит[1] == 3 and Мой_баф_юнит[0] > 0 and Дефолт[i].Name == "Mag":
							Мой_замок += Дефолт[i].damage * Множитель_урона_для_крепости
							if Мой_замок > Point:
								Мой_замок = Point

						Чат = "Воин "+Назавние_команды+" Атакует стены замка: "+str(Дефолт[i].damage * Множитель_урона_для_крепости * Бонус_множитель)

						if Ходит_Л:
							Хп_П = Противник_замок
							Хп_Л = Мой_замок
							if Хп_П <= 0:
								Win_L = True
								Хп_П = 0
						else:
							Хп_Л = Противник_замок
							Хп_П = Мой_замок
							if Хп_Л <= 0:
								Win_L = False
								Хп_Л = 0

						Звук_Урон()
						print_zamok()
						time.sleep(0.5)

						break

			Дефолт = Сортировка_войнов(Дефолт)
				
	Войны_Хитбоксы()

def Атака(Атакующий, Потерпевший, Чатик): # Чатик (Для вывода информации о ударах в глоб. чат) - "L" Если атакует левый "R" - Если правый
	# Бой между 2-мя солдатами

	# Берем все нужные глобальные переменные
	global Войны_П, Войны_Л, Игровое_поле, Чат

	# Задаем три переменные, по ним будет определяться исход стычки
	Атака = False
	Ничья = False
	Контр_атака = False

	Результат = random.choices(["Атакующий", "Потерпевший", "Ничья"], weights=[Атакующий.hp, Потерпевший.hp, round((Атакующий.hp + Потерпевший.hp) / 2)])

	if Результат[0] == "Атакующий":
		Атака = True
	elif Результат[0] == "Ничья":
		Ничья = True
	elif Результат[0] == "Потерпевший":
		Контр_атака = True

	# Определяем какой результат схватки (3 варианта)
	if Атака:                                                                    # 1 - Атакующий снимает hp Потерпевшему
		Удар = 1
		Потерпевший.hp -= Атакующий.damage
		
		# Если убили
		if Потерпевший.hp <= 0:
			# Присваеваем -1 hp убитому, он потом будет очищен функцией Очистка_Войнов()
			Потерпевший.hp = -1

			Игровое_поле[Потерпевший.coord] = " "
			Игровое_поле[Потерпевший.coord-41] = " "
			Игровое_поле[Потерпевший.coord+41] = "#"

			Звук_Kill()
		else:
			Звук_Урон()

	elif Ничья:                                                                  # 2 - Потерпевший отразил удар (Ничья)
		Удар = 2
		Звук_ничья()


	elif Контр_атака:                                                            # 3 - Потерпевший сделал контр-атаку
		Удар = 3
		Атакующий.hp -= Потерпевший.damage
		
		if Атакующий.hp <= 0:

			# Присваеваем -1 hp убитому, он потом будет очищен функцией Очистка_Войнов()
			Атакующий.hp = -1

			Игровое_поле[Атакующий.coord] = " "
			Игровое_поле[Атакующий.coord-41] = " "
			Игровое_поле[Атакующий.coord+41] = "#"

			Звук_Kill()
		else:
			Звук_Урон()


	if Удар == 1:
		if Чатик == "L":
			Чат = "Воин "+Назавние_левой_команды+" наносит урон: "+str(Атакующий.damage)
		else:
			Чат = "Воин "+Назавние_правой_команды+" наносит урон: "+str(Атакующий.damage)
	elif Удар == 2:
		if Чатик == "L":
			Чат = "Воин "+Назавние_правой_команды+" отразил удар "
		else:
			Чат = "Воин "+Назавние_левой_команды+" отразил удар "
	elif Удар == 3:
		if Чатик == "L":
			Чат = "Воин "+Назавние_правой_команды+" контратаковал и нанес: "+str(Потерпевший.damage)
		else:
			Чат = "Воин "+Назавние_левой_команды+" контратаковал и нанес: "+str(Потерпевший.damage)

def Просчет_статусов_войнов():
	# Счиатет сколько ходов действует эффект огня или заморозки
	global Войны_Л, Войны_П, Игровое_поле


	# Для левой команды
	for i in Войны_Л:

		if i.i_status == 0:
			i.status = "Norm"
		else:
			i.i_status -= 1
			# Если статус "Огонь", то снимаем хп
			if i.status == "Fire":
				i.hp -= 1
				# Если умер от огня, то удаляем из списка и очищаем поле
				if i.hp <= 0:
					Игровое_поле[i.coord] = " "
					Игровое_поле[i.coord-41] = " "
					Игровое_поле[i.coord+41] = "#"
					i.hp = -1
			if i.i_status == 0:
				i.status = "Norm"

	# Для правой команды
	for i in Войны_П:

		if i.i_status == 0:
			i.status = "Norm"
		else:
			i.i_status -= 1
			# Если статус "Огонь", то снимаем хп
			if i.status == "Fire":
				i.hp -= 1
				# Если умер от огня, то удаляем из списка и очищаем поле
				if i.hp <= 0:
					Игровое_поле[i.coord] = " "
					Игровое_поле[i.coord-41] = " "
					Игровое_поле[i.coord+41] = "#"
					i.hp = -1
			if i.i_status == 0:
				i.status = "Norm"

	Войны_Хитбоксы()


def Поиск_война(Команда,coord, status):
	# status = 1 :Возвращает True если на coord находится Воин из Команды
	# status != 1 :Возвращает Война из команды, кот. находится на coord
	for i in Команда:
		if i.coord == coord:
			if status == 1:
				return True
			else:
				return i

def Очистка_Войнов():
	# Удаляет войнов из списков с отрицательным здоровьем
	global Войны_Л, Войны_П

	Войны_Л =  list(filter(lambda x: x.hp > 0, Войны_Л))
	Войны_П =  list(filter(lambda x: x.hp > 0, Войны_П))
	

def Сортировка_войнов(Команда):
	# Сортирует войнов в списке по расположению на игровом поле от левого замка до правого. Нужно для поочередной ходьбы
	global Войны_Л, Войны_П
	# Сортируем войнов левой команды
	if Команда == Войны_Л:
		Войны_Л = sorted(Войны_Л, key = lambda Воин: Воин.coord)
		return Войны_Л
	# Сортируем войнов правой команды
	else:
		Войны_П = sorted(Войны_П, key = lambda воин: воин.coord)
		return Войны_П

def Добавить_война(Ходит_Л, n): # если Ходит_Л True, то добавляем на поле левого война n - номер война 1 - легкий 2 - тяжелый
	global Войны_Л, Войны_П

	# Изначально все бафы == 0
	Баф_xp = 0
	Баф_V = 0

	# Присваеваем temp переменной Список с бафом
	Мой_баф = Баф_Л if Ходит_Л else Баф_П

	# Образец
	if Ходит_Л:
		Образ_лег = Образец_война_легкая_пехота_L
		Образ_тяж = Образец_война_тяжелая_пехота_L
	else:
		Образ_лег = Образец_война_легкая_пехота_R
		Образ_тяж = Образец_война_тяжелая_пехота_R

	# Высчитываем бафы
	if Мой_баф[0] != 0:
		if Мой_баф[1] == 1: # Войнам +2xp
			Баф_xp = 2
		elif Мой_баф[1] == 2: # Войнам +2V
			Баф_V = 2


	if Ходит_Л:
		if n == 1:
			Войны_Л.append(Воин(Образ_лег[0] + Баф_xp, Образ_лег[1], Образ_лег[2], Образ_лег[3], Образ_лег[4] + Баф_V, Образ_лег[5], Образ_лег[6], Образ_лег[7], Образ_лег[8]))
		elif n == 2:
			Войны_Л.append(Воин(Образ_тяж[0] + Баф_xp, Образ_тяж[1], Образ_тяж[2], Образ_тяж[3], Образ_тяж[4] + Баф_V, Образ_тяж[5], Образ_тяж[6], Образ_тяж[7], Образ_тяж[8]))
	else:
		if n == 1:
			Войны_П.append(Воин(Образ_лег[0] + Баф_xp, Образ_лег[1], Образ_лег[2], Образ_лег[3], Образ_лег[4] + Баф_V, Образ_лег[5], Образ_лег[6], Образ_лег[7], Образ_лег[8]))
		elif n == 2:
			Войны_П.append(Воин(Образ_тяж[0] + Баф_xp, Образ_тяж[1], Образ_тяж[2], Образ_тяж[3], Образ_тяж[4] + Баф_V, Образ_тяж[5], Образ_тяж[6], Образ_тяж[7], Образ_тяж[8]))

def Огонь_у_замка(Ходит_Л): # если Ходит_Л True, то огонь у левого замка. False - У правого
	# Запоминаем координаты у замков
	Координаты_у_стен = [466, 467, 468, 426] if Ходит_Л else [475, 476, 477, 435]
	
	# Заранее создаем список в кот. будут находиться координаты войнов под огнем
	Пострадавшие = []

	# Проверяем наличие войнов в этих координатах
	for i in Координаты_у_стен:
		if Игровое_поле[i] != " ":
			Пострадавшие.append(i)

	# Если пострадавшие есть
	if len(Пострадавшие) > 0:
		global Войны_Л, Войны_П

		for i in Войны_Л:
			if i.coord in Пострадавшие:
				i.status = "Fire"
				i.i_status = 3

		for i in Войны_П:
			if i.coord in Пострадавшие:
				i.status = "Fire"
				i.i_status = 3

	# Рисуем изображение
	for i in Координаты_у_стен:
		Игровое_поле[i] = "R"

	print_zamok()
	Звук_Fire()
	time.sleep(1)

	# Стираем изображение
	for i in Координаты_у_стен:
		Игровое_поле[i] = " "

	Войны_Хитбоксы()
	#Монеты_и_бафы_хитбоксы()



def  Выстрел_катапульты():
	global Чат, INPUT

	# Выстрел с катапульты

	# Цвета
	os.system("cls")
	RES = Fore.BLACK + Back.WHITE
	red = Fore.RED + Back.RED
	yel = Fore.YELLOW + Back.YELLOW
	gren = Fore.GREEN + Back.GREEN
	res = Fore.BLACK + Back.WHITE
	cyan = Fore.BLACK + Back.CYAN
	# Цвет подсказки
	Назавние_команды = L_color if Ходит_Л else R_color

	# Отступы
	print(13 * "\n" + 39 * " ", end="") 
	print(Назавние_команды+'             "Enter" - Выбор            '+RES)

	
	# Полоска для попаданий
	print("\n" + 39 * " " + red + 2 * "      " + yel + 2 * "   " + gren + "    " + yel + 2 * "   " + red + 2 * "      " + res)

	
	# cd D:/Python & D: & python Замки.py

	# Задаем 3 переменных
	INPUT = None
	inp = 0
	r = True
	Бонус = False


	# От 11 до 28 Попадание
	# От 18 до 21 Бонус

	# Цикл
	while True:

		if r:
			inp += 1
		else:
			inp -= 1

		print(39*" ",end="")
		print("\r"+39*" "+inp*" "+"*",end="")
		print("\r"+39*" ",end=15*" ")

		if inp >= 5 and inp <= 35: #RED
			#time.sleep(0.003)
			time.sleep(0.01)
			#time.sleep(0.04)
		
		elif inp >= 10 and inp <= 30: #YELLOW
			time.sleep(0.008)
			#time.sleep(0.04)
		

		elif inp >= 15 and inp <= 25: #GREEN
			time.sleep(0.001)
			#time.sleep(0.04)
		
		else:
			time.sleep(0.04) # Края

		Ввод_через_буфер()

		if INPUT == "":
			break

		if inp == 39:
			r = False
		elif inp == 0:
			r = True

	time.sleep(1)

	# Присваеваем скин
	skin = Снаряд_L.skin if Ходит_Л else Снаряд_R.skin

	if Ходит_Л:
		По_ветру = True if Ветер_Направо else False
	else:
		По_ветру = False if Ветер_Направо else True


	if По_ветру:
		# Полет
		if inp > 11 and inp < 28:
			# Если попал в зеленую область
			if inp >= 18 and inp <= 21:
				Бонус = True
				Полет_в_замок(0, skin, Бонус)

			# Если попал в желтую область
			else:

				Temp1 = -2 if Ходит_Л else -1
				Temp2 = 4 if Ходит_Л else 4

				# Отдельная каректировка полета для желтой области
				if inp > 11 and inp < 18:
					inp = random.randint(Temp1, -1)
				elif inp > 21 and inp < 28:
					inp = random.randint(1, Temp2)

				Полет_в_замок(inp, skin, Бонус)
		# Красная область
		else:
			if inp <= 11: # Вниз
				Полет_в_замок(-101, skin, Бонус)
			else:
				Полет_в_замок(-101, skin, Бонус)
	else:
		# Бонус
		if inp >= 18 and inp <= 21:
			Бонус = True

		Полет_в_война(inp, skin, Бонус)

	print_zamok()
	


def Полет_в_замок(k, skin, Бонус): # cd D:/Python & D: & python Замки.py
	global Л_Катапульта, П_Катапульта, Ходит_Л, Чат, Хп_Л, Хп_П, Снаряд_L, Снаряд_R, Win_L

	# k - коэффицент, который изменяет траекторию полета
	# Работает нормально только при k >= -2 and k <= 6 (Для левой)
	# Работает нормально только при k >= -1 and k <= 4 (Для правой)
	# Если (k == -100) or (k == -101) значит игрок попал в красную область и промахнулся
	# -101 Вверх
	# -100 Вниз


	# Если попал
	if k > -100:
		# Дефолтные траектории
		Траектория = [261, 222, 185, 231, 275, 319] if Ходит_Л else [272, 229, 185, 220, 258, 296]
		# Меняем траекторию
		Траектория = list(map(lambda x : x - 41*(k), Траектория))
	# Если промахнулся вверх
	elif k == -101:
		# Если промахнулись вверх
		Траектория = [219,138,58,19] if Ходит_Л else [232,149,65,22]
		Чат = "Снаряд вылетел за пределы игрового поля"
	# Если промахнулся вниз
	else:
		# Если промахнулись вниз (Так же как и вверх)
		Траектория = [219,138,58,19] if Ходит_Л else [232,149,65,22]
		Чат = "Снаряд вылетел за пределы игрового поля" 

	print_zamok()
	time.sleep(1)

	if Ходит_Л:
		Л_Катапульта = True
	else:
		П_Катапульта = True

	Катапульты_хитбоксы()
	Звук_Выстрел()
	print_zamok()
	
	for i in Траектория:
		Игровое_поле[i] = skin

		print_zamok()
		time.sleep(0.1)

		Игровое_поле[i] = " "


	# Если игрок попал 
	if k > -100:
		# Отдельно задаем формулу для поиска препятствия для разных замков
		# Поиск следующих препятствий ищется по диагонали
		Формула = 42 if Ходит_Л else 40
		L_R = 1 if Ходит_Л else -1

		# Поиск препятствия после пролета
		for i in range(6):
			if Игровое_поле[Траектория[-1] + L_R] == "#" or Игровое_поле[Траектория[-1] + L_R] == "M":

				# Присваем к темп противоположное значение от Ходил_Л
				Temp = not Ходит_Л

				Физика_разрушения(Траектория[-1] + L_R, Temp)
				break
			else:
				Игровое_поле[Траектория[-1]] = skin

				print_zamok()
				time.sleep(0.1)

				Игровое_поле[Траектория[-1]] = " "

				Траектория[-1] += Формула

		Мои_хп = Хп_П if Ходит_Л else Хп_Л

		damage = Снаряд_L.damage if Ходит_Л else Снаряд_R.damage

		if Бонус:
			damage = damage + (damage // 2)

		Мои_хп -= damage

		if Ходит_Л:
			Хп_П = Мои_хп
			if Хп_П <= 0:
				Win_L = True
				Хп_П = 0
		else:
			Хп_Л = Мои_хп
			if Хп_Л <= 0:
				Win_L = False
				Хп_Л = 0

		print_zamok()
		time.sleep(1)

	if Ходит_Л:
		Л_Катапульта = False
		Снаряд_L = Снаряд_катапульты(0," ")
	else:
		П_Катапульта = False
		Снаряд_R = Снаряд_катапульты(0," ")

	Катапульты_хитбоксы()

def Полет_в_война(k, skin, Бонус, coord_ИИ = 0):
	global Игровое_поле, Войны_П, Войны_Л, Чат, Л_Катапульта, П_Катапульта, INPUT, Снаряд_R, Снаряд_L
	# k - коэффицент, который определяет в какого война попали
	# Если (k == -100) or (k == -101) значит игрок попал в красную область и промахнулся
	# -101 Вверх
	# -100 Вниз

	# От 11 до 28 Попадание
	# От 18 до 21 Бонус

	Дефолт_траектория = [259, 96, 15] if Ходит_Л else [274, 109, 26]

	# Отчищаем на всякий случай
	Очистка_Войнов()
	
	Мои_войны = Войны_Л if Ходит_Л else Войны_П
	Войны_противника = Войны_П if Ходит_Л else Войны_Л
	
	
	index_dead = -1 # Индекс в списке убитого
	эффект = 0 # Эффект от выстрела
	время_эффекта = 0

	# Проигрывание дефолтного полета вверх если не попал в зел область
	if not Бонус:

		Л_Катапульта = True if Ходит_Л else False
		П_Катапульта = True if not Ходит_Л else False
		Звук_Выстрел()
		Катапульты_хитбоксы()

		for i in Дефолт_траектория:

			Игровое_поле[i] = skin

			print_zamok()
			time.sleep(0.1)

			Игровое_поле[i] = " "


	# Если войны есть
	if sum([len(Войны_Л), len(Войны_П)]) != 0 or Бонус:

		if skin == "B":
			эффект = "Freeze"
			время_эффекта = 4
		elif skin == "R":
			эффект = "Fire"
			время_эффекта = 4

		# Просчеты

		# Если игрок попал в ЗЕЛЕНУЮ область
		if Бонус:


			if Ходит_Л or (not Ходит_Л and not Игра_против_ИИ):
				# Даем выбор игроку в кого стрелять
				if len(Войны_противника) != 0:
					Чат = "Выберите война"

					num_воин = 0; INPUT = ""

					Диапазон_выбора = len(Войны_противника) if len(Войны_противника) <= 5 else 5

					print("\n" + 53 * " ", end  = "")

					# Вывод всех номеров (max = 5) и их выбор

					if not Ходит_Л:
						Войны_противника.reverse()

					Рамка = ""
					temp = [0] # Список для хранения отступов войнов

					def Рамка_для_войнов(x):
						return "num" + str(x)


					# Создаем рамки
					for i in range(len(Войны_противника)):

						Игровое_поле[Войны_противника[i].coord - 123] = Рамка_для_войнов(i + 1)

						num_воин = i + 1 # Переменная для ограничений выбора война

						if i == 4:
							break

					temp_list = [str(i) for i in range(1, num_воин + 1)]


					print_zamok()


					# cd D:/Python & D: & python Замки.py
					# Ввод
					while INPUT not in temp_list:
						time.sleep(0.01)
						Ввод_через_буфер()
					del temp_list

					index_dead = int(INPUT) - 1
					
					# Убираем рамки
					for i in range(len(Войны_противника)):
						Игровое_поле[Войны_противника[i].coord - 123] = " "
						if i == 4:
							break


					print_zamok()
					time.sleep(1)


					Л_Катапульта = True if Ходит_Л else False
					П_Катапульта = True if not Ходит_Л else False
					Звук_Выстрел()
					Катапульты_хитбоксы()
					

					# Проигрывание дефолтного полета вверх
					for i in Дефолт_траектория:

						Игровое_поле[i] = skin

						print_zamok()
						time.sleep(0.1)

						Игровое_поле[i] = " "
					k =  20

				else: # ФИЧААА )))
					Бонус = True
					Полет_в_замок(0, skin, Бонус)
					k = 0

			else:

				'''
				Л_Катапульта = True if Ходит_Л else False
				П_Катапульта = True if not Ходит_Л else False
				Звук_Выстрел()
				Катапульты_хитбоксы()
				'''

				if len(Войны_Л) != 0:

					# Дефолтный полет вверх
					Л_Катапульта = True if Ходит_Л else False
					П_Катапульта = True if not Ходит_Л else False
					Звук_Выстрел()
					Катапульты_хитбоксы()

					for i in Дефолт_траектория:

						Игровое_поле[i] = skin

						print_zamok()
						time.sleep(0.1)

						Игровое_поле[i] = " "

					# Присваиваем индекс в попадаемого
					for i in range(len(Войны_Л)):
						if Войны_Л[i].coord == coord_ИИ:
							index_dead = i
					k =  20
				else:
					Бонус = True
					Полет_в_замок(0, skin, Бонус)
					k = 0

			

		# Если игрок попал в ЖЕЛТУЮ область (Умирает рандомный войн) # Код для желтой области напрямую связан с зеленой

		if k > 11 and k < 28:
			# Шанс убивает рандомного война на карте

			if index_dead == -1:
				Temp = random.randint(0, 1)
			else:
				Temp = 1 if Ходит_Л else 0


			if Temp == 0:
				# L
				
				if len(Войны_Л) != 0:

					if index_dead == -1:
						index_dead = random.randint(0, len(Войны_Л) - 1)

					Полет_Вниз(skin, Войны_Л[index_dead].coord)

					Войны_Л[index_dead].hp -= 5

					# Звук
					if Войны_Л[index_dead].hp <= 0:
						Звук_Kill()
						time.sleep(0.1)

						Игровое_поле[Войны_Л[index_dead].coord] = " "
						Игровое_поле[Войны_Л[index_dead].coord - 41] = " "
						Игровое_поле[Войны_Л[index_dead].coord + 41] = "#"
					else:
						Звук_Камень()
						time.sleep(0.3)


					if эффект != 0:
						# Запоминаем скин клетки, чтобы потом его вернуть
						Клетка_R = Игровое_поле[Войны_Л[index_dead].coord + 1]
						Клетка_L = Игровое_поле[Войны_Л[index_dead].coord - 1]
						Клетка_центр = Игровое_поле[Войны_Л[index_dead].coord]


						# Центр
						Игровое_поле[Войны_Л[index_dead].coord] = skin
						Клетка_под_эффектом(Войны_Л[index_dead].coord, эффект, время_эффекта)

						print_zamok()
						time.sleep(0.2)
						Войны_Хитбоксы()

						# Право
						if Клетка_R != "#":
							Игровое_поле[Войны_Л[index_dead].coord + 1] = skin
							Клетка_под_эффектом(Войны_Л[index_dead].coord + 1, эффект, время_эффекта)

							print_zamok()
							time.sleep(0.2)
							Войны_Хитбоксы()

						# Лево
						if Клетка_L != "#":
							Игровое_поле[Войны_Л[index_dead].coord - 1] = skin
							Клетка_под_эффектом(Войны_Л[index_dead].coord - 1, эффект, время_эффекта)

							print_zamok()
							time.sleep(0.2)
							Войны_Хитбоксы()

						Игровое_поле[Войны_Л[index_dead].coord] = Клетка_центр; Игровое_поле[Войны_Л[index_dead].coord + 1] = Клетка_R; Игровое_поле[Войны_Л[index_dead].coord -1] = Клетка_L
						print_zamok()
						Войны_Хитбоксы()


				else:
					Чат = "Промах"

			else:
				# R
				if len(Войны_П) != 0:

					if index_dead == -1:
						index_dead = random.randint(0, len(Войны_П) - 1)

					Полет_Вниз(skin, Войны_П[index_dead].coord)

					Войны_П[index_dead].hp -= 5

					# Звук
					if Войны_П[index_dead].hp <= 0:
						Звук_Kill()
						time.sleep(0.1)

						Войны_П[index_dead].hp <= 0
						Игровое_поле[Войны_П[index_dead].coord] = " "
						Игровое_поле[Войны_П[index_dead].coord - 41] = " "
						Игровое_поле[Войны_П[index_dead].coord + 41] = "#"
					else:
						Звук_Камень()
						time.sleep(0.3)


					if эффект != 0:
						# Запоминаем скин клетки, чтобы потом его вернуть
						Клетка_R = Игровое_поле[Войны_П[index_dead].coord + 1]
						Клетка_L = Игровое_поле[Войны_П[index_dead].coord - 1]
						Клетка_центр = Игровое_поле[Войны_П[index_dead].coord]


						# Центр
						Игровое_поле[Войны_П[index_dead].coord] = skin
						Клетка_под_эффектом(Войны_П[index_dead].coord, эффект, время_эффекта)

						print_zamok()
						time.sleep(0.2)
						Войны_Хитбоксы()

						# Право
						if Клетка_R != "#":
							Игровое_поле[Войны_П[index_dead].coord + 1] = skin
							Клетка_под_эффектом(Войны_П[index_dead].coord + 1, эффект, время_эффекта)

							print_zamok()
							time.sleep(0.2)
							Войны_Хитбоксы()

						# Лево
						if Клетка_L != "#":
							Игровое_поле[Войны_П[index_dead].coord - 1] = skin
							Клетка_под_эффектом(Войны_П[index_dead].coord - 1, эффект, время_эффекта)

							print_zamok()
							time.sleep(0.2)
							Войны_Хитбоксы()

						Игровое_поле[Войны_П[index_dead].coord] = Клетка_центр; Игровое_поле[Войны_П[index_dead].coord + 1] = Клетка_R; Игровое_поле[Войны_П[index_dead].coord -1] = Клетка_L
						print_zamok()
						Войны_Хитбоксы()

				else:
					Чат = "Промах"

		# Если игрок попал в КРАСНУЮ область
		else:
			if k != 0:
				Чат = "Промах"


	Л_Катапульта, П_Катапульта = False, False
	Снаряд_L = Снаряд_катапульты(0," "); Снаряд_R = Снаряд_катапульты(0," ")

	Катапульты_хитбоксы()

def Полет_Вниз(skin, coord):
	coord -= 82 
	Траектория = [coord - (i * 123) for i in range(3)]
	Траектория.reverse()
	print_zamok()
	time.sleep(1)
	for i in range(3):
		Игровое_поле[Траектория[i]] = skin; print_zamok(); time.sleep(0.1); Игровое_поле[Траектория[i]] = " "

def Клетка_под_эффектом(coord, эффект, TIME):
	# Передает эффект войну, который находится на клетке
	if эффект != 0:
		if Игровое_поле[coord] != " " and Игровое_поле[coord] != "#":
			global Войны_Л, Войны_П

			for i in Войны_Л:
				if i.coord == coord:
					i.status = эффект
					i.i_status = TIME
					Звук_Заморозки() if эффект == "Freeze" else Звук_Fire()
					break

			for i in Войны_П:
				if i.coord == coord:
					i.status = эффект
					i.i_status = TIME
					Звук_Заморозки() if эффект == "Freeze" else Звук_Fire()
					break

# Бафы
def Спавн_бафа():
	# Создает на игровом поле баф "U"
	Клетки_для_бафа = [i for i in range(467, 477) if Игровое_поле[i] == " "]
	if len(Клетки_для_бафа) != 0:
		random.shuffle(Клетки_для_бафа)
		#########################################################################################################
		#Клетки_для_бафа[0] = 469
		#########################################################################################################
		Смещение = 123
		Звук_U()
		for i in range(3):
			Игровое_поле[Клетки_для_бафа[0] - Смещение] = " "
			Смещение -= 41
			Игровое_поле[Клетки_для_бафа[0] - Смещение] = "U"
			print_zamok()
			time.sleep(0.5)


def Эффект_баф(Воин):
	
	# Все бафы делятся на 3 типа (Временные) (Моментальные) (Деньги)
	# Деньги относятся к моментальным, но они здесь для того, чтобы чаще выпадать

	''' Таблица всех общих временных бафов
	1 - У созданных войнов +2 xp
	2 - У созданных войнов +2 к скорости
	3 - Магические войны при штурме стен вражеского замка прибавляют отнимаемый урон в свой замок
	4 - Увеличен можитель крепости при штурме вражеского замка
	'''

	''' Таблица всех моментальных бафов
	1 - Моментальная починка замка
	2 - Спавн магического война
	3 - Заморозить  всех вражеских войск на 3 хода
	4 - Прибавть войну +2 xp
	5 - Прибавить всем войнам +1 xp
	'''

	global Баф_Л, Баф_П, Войны_Л, Войны_П, Чат, Монеты_П, Монеты_Л

	Цвет_текста = L_color if Ходит_Л else R_color

	Временные_бафы = [1, 2, 3, 4]
	Моментальные_бафы = [1, 2, 3, 4]
	Деньги_баф = [0]

	Рандомный_баф = random.randint(1, 3)

	if Рандомный_баф == 1:
		random.shuffle(Временные_бафы)
		Итог_баф = [random.randint(6, 9), Временные_бафы[0]]

		if Итог_баф[1] == 1:
			Чат = Цвет_текста + "Бонус: У созданных войнов " + Back.RED + Fore.WHITE + "+2hp" + Back.WHITE + Fore.BLACK
		elif Итог_баф[1] == 2:
			Чат = Цвет_текста + "Бонус: У созданных войнов " + Back.BLUE + Fore.WHITE + "+2V" + Back.WHITE + Fore.BLACK
		elif Итог_баф[1] == 3:
			Чат = Цвет_текста + "Бонус: При атаке замка магическими войнами урон регенерируется в свой замок" + Back.WHITE + Fore.BLACK
		elif Итог_баф[1] == 4:
			Чат = Цвет_текста + "Бонус: " + Back.MAGENTA + Fore.WHITE + "Увеличен урон при штурме крепости 2X" + Back.WHITE + Fore.BLACK

		Звук_Bonus()

	elif Рандомный_баф == 2: # cd D:/Python & D: & python Замки.py
		
		# Добавляем 5 т.к больше вариантов
		Моментальные_бафы.append(5)
		# Дополнительный код (Убираем эффект Freeze если на поле нету вражеских войск)
		Войны_temp = Войны_П if Ходит_Л else Войны_Л
		if len(Войны_temp) == 0:
			Моментальные_бафы.remove(3)
		del Войны_temp
		# Дополнительный код (Убираем Моментальную починку замка если хп == point)
		Мои_хп = Хп_Л if Ходит_Л else Хп_П
		if Мои_хп == Point:
			Моментальные_бафы.remove(1)
		del Мои_хп

		random.shuffle(Моментальные_бафы)
		Итог_баф = [0, Моментальные_бафы[0]]

		# Починка замка
		if Итог_баф[1] == 1:
			Чат = Цвет_текста + "Бонус: " + Back.RED + Fore.WHITE + "Моментальная починка замка" + Back.WHITE + Fore.BLACK

			print_zamok()
			time.sleep(3)
			Починить_замок("L" if Ходит_Л else "R")
		# Магический воин
		elif Итог_баф[1] == 2:
			Чат = Цвет_текста + "Бонус: " + Back.BLUE + Fore.WHITE + "Бесплатный магический войн" + Back.WHITE + Fore.BLACK

			Диапазон_клеток = [i for i in range(466, 478)]

			if not Ходит_Л:
				Диапазон_клеток.reverse()

			for i in Диапазон_клеток:
				if Игровое_поле[i] == " ":
					Добавить_война(Ходит_Л, 1)

					if Ходит_Л:
						Войны_Л[-1].coord = i
					else:
						Войны_П[-1].coord = i

					Звук_heal()
					Войны_Хитбоксы()
					break
		# Freeze
		elif Итог_баф[1] == 3:
			Чат = Цвет_текста + 'Бонус: Эффект ' + Back.BLUE + Fore.WHITE + '"Freeze"' + Цвет_текста + ' на всех вражеский войнов на 3 хода' + Back.WHITE + Fore.BLACK

			if Ходит_Л:
				if len(Войны_П) >= 0:
					for i in Войны_П:
						if i.status == "Norm":
							i.status = "Freeze"; i.i_status = 3

							Звук_Заморозки()
							Войны_Хитбоксы()
							print_zamok()
							time.sleep(0.4)
			else:
				if len(Войны_Л) >= 0:
					for i in Войны_Л:
						if i.status == "Norm":
							i.status = "Freeze"; i.i_status = 3
							
							Звук_Заморозки()
							Войны_Хитбоксы()
							print_zamok()
							time.sleep(0.4)

		# 1 воин получает +2hp
		elif Итог_баф[1] == 4:
			Чат = Цвет_текста + "Бонус: войн получает " + Back.RED + Fore.WHITE + "+2hp" + Back.WHITE + Fore.BLACK

			if Воин.hp != 9:
				Воин.hp += 2
				Звук_heal()
				if Воин.hp > 9:
					Воин.hp = 9
				Войны_Хитбоксы()
				print_zamok()

		# Все войны получают +1hp
		elif Итог_баф[1] == 5:
			Чат = Цвет_текста + "Бонус: Все войны получают " + Back.RED + Fore.WHITE + "+1hp" + Back.WHITE + Fore.BLACK

			if Ходит_Л:
				if len(Войны_Л) >= 0:
					for i in Войны_Л:
						if i.hp != 9:
							i.hp += 1
							Звук_heal()
							if i.hp > 9:
								i.hp = 9

							Войны_Хитбоксы()
							print_zamok()
							time.sleep(0.4)
			else:
				if len(Войны_П) >= 0:
					for i in Войны_П:
						if i.hp != 9:
							i.hp += 1
							Звук_heal()
							if i.hp > 9:
								i.hp = 9
								
							Войны_Хитбоксы()
							print_zamok()
							time.sleep(0.4)
			

	elif Рандомный_баф == 3:
		Итог_баф = [0, 0]
		Temp_монеты = random.randint(50, 100)
		Звук_kush()

		if Ходит_Л:
			Монеты_Л += Temp_монеты
		else:
			Монеты_П += Temp_монеты

		Чат = Цвет_текста + "Бонус: Бесплатные монеты " + Back.RED + Fore.WHITE + str(Temp_монеты) + Back.WHITE + Fore.BLACK


	print_zamok()
	time.sleep(4)

	if Ходит_Л:
		Баф_Л = Итог_баф
	else:
		Баф_П = Итог_баф

def Назавание_бонуса(A):
	# Возвращает краткий тект о бонусе

	''' Таблица всех общих временных бафов
	1 - У созданных войнов +2 xp
	2 - У созданных войнов +2 к скорости
	3 - Магические войны при штурме стен вражеского замка прибавляют отнимаемый урон в свой замок
	4 - Увеличен можитель крепости при штурме вражеского замка
	'''


	# Если баф есть
	if A[0] != 0:
		if A[1] == 1:
			return "|" + Fore.WHITE + Back.RED + "+2xp" + Fore.BLACK + Back.WHITE + " Бонус действует: " + str(A[0]) + "х|"
		elif A[1] == 2:
			return "|" + Fore.WHITE + Back.BLUE + "+2 V" + Fore.BLACK + Back.WHITE + " Бонус действует: " + str(A[0]) + "х|"
		elif A[1] == 3:
			return "|" + Fore.RESET + Back.RESET + "МагВ" + Fore.BLACK + Back.WHITE + " Бонус действует: " + str(A[0]) + "х|"
		elif A[1] == 4:
			return "|" + Fore.RESET + Back.RESET + "2X штурм" + Fore.BLACK + Back.WHITE + " Бонус действует: " + str(A[0]) + "х|"
	else:
		return ""

		


# Функции для примеров

def Генерация_примера(сложность):

	# Возвращает список типа: [s, a, b, x, z]
	# s - Статус
	# a - a
	# b - b
	# x - x
	# z - Знак

	# Два вида примера
	пример = [1,2]

	# Если сложность стоит выше обычного, то добавляем еще 1 вид примеров
	if сложность == 1:
		пример.append(3)

	# перемешивем список
	random.shuffle(пример)


	# Обычный пример (Статус 1)
	if пример[0] == 1:
		# + - *
		ran = random.randint(1,3)

		# +
		if ran == 1:
			a = random.randint(5,99)
			b = random.randint(5,99)
			x = a + b
			z = "+"
		# -
		elif ran == 2:
			a = random.randint(5,99)
			b = random.randint(5,99)
			if b > a:
				a,b = b,a
			x = a - b
			z = "-"
		# *
		elif ran == 3:
			a = random.randint(2,9)
			b = random.randint(7,87)
			x = a * b
			z = "*"

		Пример_сейчас = [1,a,b,x,z]
		return Пример_сейчас

	# Найти X (Статус 2)
	elif пример[0] == 2:
		
		# + - * /
		ran = random.randint(1,3) #4

		ran = 3
		
		# +
		if ran == 1:
			a = random.randint(5,99)
			b = random.randint(5,99)
			x = a + b
			z = "+"

			Пример_сейчас = [2,x,b,a,z]
			return Пример_сейчас


		# -
		elif ran == 2:
			a = random.randint(5,99) # 13
			b = random.randint(5,99) # x
			if b > a:
				a,b = b,a
			x = a - b                # 56 
			z = "-"

			# list 2   "x"  list 

			Пример_сейчас = [2,x,b,a,z]
			return Пример_сейчас

		# *
		elif ran == 3:
			a = random.randint(2,9)
			b = random.randint(7,87)
			x = a * b
			z = "*"

			Пример_сейчас = [2,x,a,b,z]
			return Пример_сейчас

	# Таблица син кос (Статус 3)
	elif пример[0] == 3:
		Таблица = {
		"sin 0°": "0", "sin 30°": "1/2","sin 45°": "√2/2","sin 60°": "√3/2","sin 90°": "-1","sin 180°": "0","sin 270°": "-1","sin 360°": "0",
		"cos 0°": "1", "cos 30°": "√3/2","cos 45°": "√2/2","cos 60°": "1/2","cos 90°": "0","cos 180°": "-1","cos 270°": "0","cos 360°": "1",
		"tg 0°": "0", "tg 30°": "√3/3","tg 45°": "1","tg 60°": "√3","tg 90°": "-","tg 180°": "0","tg 270°": "-","tg 360°": "0",
		"ctg 0°": "-", "ctg 30°": "√3","ctg 45°": "1","ctg 60°": "√3/3","ctg 90°": "0","ctg 180°": "-","ctg 270°": "0","ctg 360°": "-"
		}

		# Создаем временную переменную для хранения будуещего примера
		Temp = ""
		a = random.randint(1,4)
		if a == 1:
			Temp += "sin "
		elif a == 2:
			Temp += "cos "
		elif a == 3:
			Temp += "tg "
		elif a == 4:
			Temp += "ctg "
		# Дополнительная переменная для вывода вопроса
		Temp1 = Temp[0:len(Temp)-1]

		a = random.randint(1,8)
		if a == 1:
			b = "0°"
			Temp += "0°"
		elif a == 2:
			b = "30°"
			Temp += "30°"
		elif a == 3:
			b = "45°"
			Temp += "45°"
		elif a == 4:
			b = "60°"
			Temp += "60°"
		elif a == 5:
			b = "90°"
			Temp += "90°"
		elif a == 6:
			b = "180°"
			Temp += "180°"
		elif a == 7:
			b = "270°"
			Temp += "270°"
		elif a == 8:
			b = "360°"
			Temp += "360°"

		Пример_сейчас = [3,Temp1,b,Таблица[Temp],""]
		return Пример_сейчас



def Разброс_ответа_1(LIST):
	# Выдает похожие с ответом неправильные ответы
	s = LIST[0]
	a = LIST[1]
	b = LIST[2]
	x = LIST[3]
	z = LIST[4]
	
	# seed нужен для разных закономерностей
	seed = random.randint(1,3)
	if s == 1:
		if z == "+" or z == "-":
			if seed == 1:
				n1 = x + 10
				n2 = x - random.randint(9,10)
				n3 = x - 1
			elif seed == 2:
				n1 = x + 1
				n2 = x + 2
				n3 = x - 1
			elif seed == 3:
				n1 = x + random.randint(9,10)
				n2 = x - random.randint(9,10)
				n3 = x + random.randint(11,12)
			List = [n1,n2,n3,x]
			random.shuffle(List)
			return List
		elif z == "*":
			if seed == 1:
				n1 = x + 10
				n2 = x - 10
				n3 = x - 20
			elif seed == 2 or seed == 3:
				n1 = x + 10
				n2 = x + 20
				n3 = x + 30
			List = [n1,n2,n3,x]
			random.shuffle(List)
			return List
	elif s == 2:
		if z == "+" or z == "-":
			if seed == 1:
				n1 = x + 10
				n2 = x - random.randint(9,10)
				n3 = x - 1
			elif seed == 2:
				n1 = x + 1
				n2 = x + 2
				n3 = x - 1
			elif seed == 3:
				n1 = x + random.randint(9,10)
				n2 = x - random.randint(9,10)
				n3 = x + random.randint(11,12)
			List = [n1,n2,n3,x]
			random.shuffle(List)
			return List
		elif z == "*":
			if seed == 1:
				n1 = x + random.randint(1,3)
				n2 = x - random.randint(1,3)
				n3 = x + 10
			elif seed == 2 or seed == 3:
				n1 = x + 10
				n2 = x + 20
				n3 = x + 30
			List = [n1,n2,n3,x]
			random.shuffle(List)
			return List
	elif s == 3:
		Случайные_ответы = ["0","1","-1","-","√2/2","√3/2","√3/3","√3"]
		# Удаляем ответ из списка
		for i in range(len(Случайные_ответы)):
			if Случайные_ответы[i] == x:
				del Случайные_ответы[i]
				break
		# Перемешиваем список
		random.shuffle(Случайные_ответы)
		# Возвращаем случайные ответы
		n1 = Случайные_ответы[0]
		n2 = Случайные_ответы[1]
		n3 = Случайные_ответы[2]
		List = [n1,n2,n3,x]
		random.shuffle(List)
		return List

def print_пример(LIST, LIST_X, X = False):
	global INPUT, Чат, Global_Выбор, Example

	Ввод_через_буфер()

	Дефолт = Назавние_левой_команды if Ходит_Л else Назавние_правой_команды
	Чат = "Ходит команда " + Дефолт

	RES = Fore.BLACK + Back.WHITE

	RED = Fore.RED + Back.WHITE if TIME_Z < 4 else Fore.BLACK + Back.WHITE


	if X == False:
		# Звук часов когда остается меньше 4 секнуд
		if TIME_Z < 4 and TIME_Z > -1:
			if TIME_Z % 2 != 0:
				Звук_TIK1()
			else:
				Звук_TIK2()


	print("\n" + 39 * " " + "TIME" + RED, TIME_Z, RES)

	# Центрируем пример
	# Вывод примера с статусом 1
	if LIST[0] == 1 or LIST[0] == 3:
		print( (59 - round( (len(str(LIST[1]))+len(str(LIST[2])) + 6 )/2)) * " " + str(LIST[1]) ,str(LIST[-1]) ,str(LIST[2]) + " = ?" )
	# Вывод примера с статусом 2
	elif LIST[0] == 2:
		if LIST[-1] == "+" or LIST[-1] == "*":
			print((59 - round( (len(str(LIST[1]))+len(str(LIST[2])) + 6 )/2)) * " " + str(LIST[2]) , str(LIST[-1]) , "x"  + " =", str(LIST[1]) )
		elif LIST[-1] == "-":
			print((59 - round( (len(str(LIST[1]))+len(str(LIST[2])) + 6 )/2)) * " " + "x" , str(LIST[-1]), str(LIST[2])  + " =", str(LIST[1]) )

	# Все примеры в рамку
	num1 = Пример_в_рамке(LIST_X[0])
	num2 = Пример_в_рамке(LIST_X[1])
	num3 = Пример_в_рамке(LIST_X[2])
	num4 = Пример_в_рамке(LIST_X[3])

	# Вывод Примера когда идет таймер
	if X == False:

		# Если в INPUT не None и не "", то обнуляем его
		Global_Выбор_fun(INPUT)
		Выбран_1 = Fore.BLACK + Back.GREEN if INPUT == "1" and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_2 = Fore.BLACK + Back.GREEN if INPUT == "2" and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_3 = Fore.BLACK + Back.GREEN if INPUT == "3" and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_4 = Fore.BLACK + Back.GREEN if INPUT == "4" and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK

		print(2 * "\n" + 52 * " " + Выбран_1 + num1 + RES, Выбран_2 + num2 + RES, Выбран_3 + num3 + RES, Выбран_4 + num4 + RES)
		print("\n" + 52 * " " + " 1  " + " 2  " + " 3  " + " 4  ")
	# Вывод примера после окончания времени
	else:

		Example = None # Обнуляем переменную для звука

		Выбран_1 = Fore.BLACK + Back.GREEN if LIST_X[0] == X else Fore.WHITE + Back.RED
		Выбран_2 = Fore.BLACK + Back.GREEN if LIST_X[1] == X else Fore.WHITE + Back.RED
		Выбран_3 = Fore.BLACK + Back.GREEN if LIST_X[2] == X else Fore.WHITE + Back.RED
		Выбран_4 = Fore.BLACK + Back.GREEN if LIST_X[3] == X else Fore.WHITE + Back.RED

		print(2*"\n" + 52* " " +Выбран_1+num1+RES,Выбран_2+num2+RES,Выбран_3+num3+RES,Выбран_4+num4+RES)

		if LIST_X[Global_Выбор - 1] == X and Global_Выбор != 0:
			global Монеты_Л, Монеты_П
			if Ходит_Л:
				Монеты_Л += random.randint(25, 50) # 33
			else:
				Монеты_П += random.randint(25, 50) # 33
			Звук_Oui()
		else:
			Звук_NePa()

		Global_Выбор = 0


def Пример_в_рамке(x):
	# Возвращает пример в рамке
	if len(str(x)) == 1:
		return " "+str(x)+" "
	elif len(str(x)) == 2:
		return str(x)+" "
	else:
		return str(x)


# Функции для выбора в меню


def print_menu():

	global Ходит_Л, INPUT, Перемещение_в_меню, Чат, Example, Global_Выбор
	Мои_Деньги = Монеты_Л if Ходит_Л else Монеты_П

	# Цвета для отдельных меню
	RES = Fore.BLACK + Back.WHITE
	CYAN = Back.CYAN + Fore.BLACK

	Дефолт = Назавние_левой_команды if Ходит_Л else Назавние_правой_команды
	Чат = "Ходит команда "+Дефолт


	# Вывод сообщения о пропуске в случае маленького баланса
	if Цена_деньги(100, 75, 25, 40) == False:
		Temp_color = L_color if Ходит_Л else R_color
		Чат = Temp_color + '              "0" - Скип              ' + RES
		del Temp_color

	# Если скип
	if INPUT == "0":
		global TIME_Z
		TIME_Z = 0
		Звук_skip()

	Ввод_через_буфер()

	Цены = ((100, 75, 80, 40), (75, 80, 100), (25, 50))


	# Перемещение по меню
	if Перемещение_в_меню == 0 and INPUT == "2" and Цена_деньги(75):
		Перемещение_в_меню = 1
		INPUT = None
		Global_Выбор = 0
		Звук_Example()

	elif Перемещение_в_меню == 0 and INPUT == "3" and Цена_деньги(25) and Проверка_война_у_замка():
		Перемещение_в_меню = 2
		INPUT = None
		Global_Выбор = 0
		Звук_Example()

	elif Перемещение_в_меню == 1 and (INPUT == "4" or INPUT == ""):
		Перемещение_в_меню = 0
		INPUT = None
		Global_Выбор = 0
		Звук_Example()

	elif Перемещение_в_меню == 2 and (INPUT == "3" or INPUT == ""):
		Перемещение_в_меню = 0
		INPUT = None
		Global_Выбор = 0
		Звук_Example()


	if Перемещение_в_меню == 0:
		Global_Выбор_fun(INPUT)
		Выбран_1 = Fore.BLACK + Back.GREEN if INPUT == "1" and Проверка_перезарядки(0,0) and Цена_деньги(100) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_2 = Fore.BLACK + Back.GREEN if INPUT == "2" and Цена_деньги(75) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_3 = Fore.BLACK + Back.GREEN if INPUT == "3" and Цена_деньги(25) and Проверка_война_у_замка() and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_4 = Fore.BLACK + Back.GREEN if INPUT == "4" and Проверка_перезарядки(0,3) and  Цена_деньги(40) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Цвет_цены_1 = Fore.BLACK + Back.GREEN if Цена_деньги(100) and Проверка_перезарядки(0,0) else Fore.RED + Back.BLACK
		Цвет_цены_2 = Fore.BLACK + Back.GREEN if Цена_деньги(75) else Fore.RED + Back.BLACK
		Цвет_цены_3 = Fore.BLACK + Back.GREEN if Цена_деньги(25) and Проверка_война_у_замка() else Fore.RED + Back.BLACK
		Цвет_цены_4 = Fore.BLACK + Back.GREEN if Цена_деньги(40) and Проверка_перезарядки(0,3) else Fore.RED + Back.BLACK
	elif Перемещение_в_меню == 1:
		Global_Выбор_fun(INPUT)
		Выбран_1 = Fore.BLACK + Back.GREEN if INPUT == "1" and Проверка_перезарядки(1,0) and Цена_деньги(75) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_2 = Fore.BLACK + Back.GREEN if INPUT == "2" and Проверка_перезарядки(1,1) and Цена_деньги(80) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_3 = Fore.BLACK + Back.GREEN if INPUT == "3" and Проверка_перезарядки(1,2) and Цена_деньги(100) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_4 = Fore.BLACK + Back.GREEN if INPUT == "4" and Цена_деньги(0) else Fore.RESET + Back.BLACK
		Цвет_цены_1 = Fore.BLACK + Back.GREEN if Цена_деньги(75) and Проверка_перезарядки(1,0) else Fore.RED + Back.BLACK
		Цвет_цены_2 = Fore.BLACK + Back.GREEN if Цена_деньги(80) and Проверка_перезарядки(1,1) else Fore.RED + Back.BLACK
		Цвет_цены_3 = Fore.BLACK + Back.GREEN if Цена_деньги(100) and Проверка_перезарядки(1,2) else Fore.RED + Back.BLACK
		Цвет_цены_4 = Fore.BLACK + Back.GREEN if Цена_деньги(0) else Fore.RED + Back.BLACK
	elif Перемещение_в_меню == 2 :
		Global_Выбор_fun(INPUT)
		Выбран_1 = Fore.BLACK + Back.GREEN if INPUT == "1" and Цена_деньги(25) and Проверка_война_у_замка() and Global_Выбор_fun(INPUT,1)  else Fore.RESET + Back.BLACK
		Выбран_2 = Fore.BLACK + Back.GREEN if INPUT == "2" and Цена_деньги(50) and Проверка_война_у_замка() and Проверка_перезарядки(2,1) and Global_Выбор_fun(INPUT,1)  else Fore.RESET + Back.BLACK
		Выбран_3 = Fore.BLACK + Back.GREEN if INPUT == "3" and Цена_деньги(0) and Global_Выбор_fun(INPUT,1) else Fore.RESET + Back.BLACK
		Выбран_4 = Fore.BLACK + Back.GREEN if INPUT == "4" and Цена_деньги(0) else Fore.RESET + Back.BLACK
		Цвет_цены_1 = Fore.BLACK + Back.GREEN if Цена_деньги(25) and Проверка_перезарядки(2,0) and Проверка_война_у_замка() else Fore.RED + Back.BLACK
		Цвет_цены_2 = Fore.BLACK + Back.GREEN if Цена_деньги(50) and Проверка_перезарядки(2,1) and Проверка_война_у_замка() else Fore.RED + Back.BLACK
		Цвет_цены_3 = Fore.BLACK + Back.GREEN if Цена_деньги(0) else Fore.RED + Back.BLACK
		Цвет_цены_4 = Fore.BLACK + Back.GREEN if Цена_деньги(0) else Fore.RED + Back.BLACK	

	Бонус_текст = Назавание_бонуса(Баф_Л if Ходит_Л else Баф_П)

	
	if Перемещение_в_меню == 0:
		print("\n" + 39 * " " + "TIME", TIME_Z, Бонус_текст)
		print()
		print(39 * " " + Выбран_1 + "1 - Починить замок      " + RES + " " + Цвет_цены_1 + Проверка_перезарядки(0,0,100) + RES)
		print(39 * " " + Выбран_2 + "2 - Зарядить катапульту " + RES + " " + Цвет_цены_2 + "75  Exp " + RES)
		print(39 * " " + Выбран_3 + "3 - Войны               " + RES + " " + Цвет_цены_3 + "25  Exp " + RES)
		print(39 * " " + Выбран_4 + "4 - Магический огонь    " + RES + " " + Цвет_цены_4 + Проверка_перезарядки(0,3,40) + RES)
		print("\n"+34*" "+"             <<"+str(Мои_Деньги)+" Exp>> ") 
	elif Перемещение_в_меню == 1:
		print("\n" + 39 * " " + "TIME", TIME_Z, Бонус_текст)
		print()
		print(39 * " " + Выбран_1 + "1 - Камень              " + RES + " " + Цвет_цены_1 + Проверка_перезарядки(1, 0, 75) + RES)
		print(39 * " " + Выбран_2 + "2 - Ледяной шар         " + RES + " " + Цвет_цены_2 + Проверка_перезарядки(1, 1, 80) + RES)
		print(39 * " " + Выбран_3 + "3 - Огненный шар        " + RES + " " + Цвет_цены_3 + Проверка_перезарядки(1, 2, 100) + RES)
		print(39 * " " + CYAN + "4 - Назад               " + RES + " " + CYAN + "        " + RES)
		print("\n" + 39 * " " + "             <<" + str(Мои_Деньги) + " Exp>> ")
	elif Перемещение_в_меню == 2:
		print("\n" + 39 * " " + "TIME", TIME_Z, Бонус_текст)
		print()
		print(39 * " " + Выбран_1 + "1 - Магический воин     " + RES + " " + Цвет_цены_1 + Проверка_перезарядки(2, 0, 25) + RES)
		print(39 * " " + Выбран_2 + "2 - Тяжелый пехотинец   " + RES + " " + Цвет_цены_2 + Проверка_перезарядки(2, 1, 50) + RES)
		print(39 * " " + CYAN + "3 - Назад               " + RES + " " + CYAN + "        " + RES)
		print(39 * " " + "                                        ")
		print("\n" + 39 * " " + "             <<" + str(Мои_Деньги) + " Exp>> ")

	time.sleep(0.01)

def Цена_деньги(*nums):
	# Возвращает True, если хоть 1 число больше Монеток игрока который ходит

	global Монеты_Л, Монеты_П
	Мои_Деньги = Монеты_Л if Ходит_Л else Монеты_П

	list = nums
	
	return True if any(map(lambda x: Мои_Деньги >= x, list)) else False

def Проверка_перезарядки(a, b, Цена = None):
	global Перезарядка_пунктов_L, Перезарядка_пунктов_R
	Моя_Перезарядка = Перезарядка_пунктов_L if Ходит_Л else Перезарядка_пунктов_R

	if Цена == None:
		# Возвращает True, если перезарядка == 0
		if Моя_Перезарядка[a][b] == 0:
			return True
		else:
			return False
	else:

		if len(str(Цена)) == 3:
			space = 1
		else:
			space = 2

		if Моя_Перезарядка[a][b] == 0:
			return str(Цена) + space * " " + "Exp "
		else:
			if Моя_Перезарядка[a][b] == 1:
				return " " + str(Моя_Перезарядка[a][b]) + " Ход  "
			elif Моя_Перезарядка[a][b] == 2 or Моя_Перезарядка[a][b] == 3 or Моя_Перезарядка[a][b] == 4:
				return " " + str(Моя_Перезарядка[a][b]) + " Хода "
			elif Моя_Перезарядка[a][b] == 5 or Моя_Перезарядка[a][b] == 6:
				return str(Моя_Перезарядка[a][b])+" Ходов "


def Global_Выбор_fun(INPUT, status = 0):
	# Оставляет значение INPUT
	global Global_Выбор, Example
	
	if status == 1:
		Global_Выбор = int(INPUT)
		if Example != int(INPUT):
			Example = int(INPUT)
			if Решение_примера == False:
				Звук_Example()
		return True
	elif status == 0:
		if INPUT != None or INPUT != "":
			Global_Выбор = 0


def Проверка_война_у_замка():
	# Запрещает разместь война если у стен что-то есть
	if Ходит_Л:
		return True if Игровое_поле[466] == " " else False
	else:
		return True if Игровое_поле[477] == " " else False


def Выбор_игрока(): #cd D:/Python & D: & python Замки.py
	global Перемещение_в_меню, Global_Выбор, Ходит_Л, Монеты_П, Монеты_Л, Перезарядка_пунктов_L, Перезарядка_пунктов_R

	
	if Global_Выбор != 0:

		Мои_Деньги = Монеты_Л if Ходит_Л else Монеты_П
		Мои_пункты = Перезарядка_пунктов_L if Ходит_Л else Перезарядка_пунктов_R

		# Главное меню
		if Перемещение_в_меню == 0:
			# Починить замок
			if Global_Выбор == 1:
				Починить_замок("L" if Ходит_Л else "R")
				print_zamok()
				time.sleep(3)
				Мои_Деньги -= 100
				Мои_пункты[0][0] = 3 # Блокировка на 4 хода
			# Магический огонь
			elif Global_Выбор == 4:
				Огонь_у_замка(Ходит_Л)
				print_zamok()
				time.sleep(1)
				Мои_Деньги -= 40
				Мои_пункты[0][3] = 6 # Блокировка на 6 ходов


		# Зарядить катапульту
		elif Перемещение_в_меню == 1:
			global Снаряд_L, Снаряд_R
			# Камень
			if Global_Выбор == 1:
				Дефолт = Снаряд_катапульты(60,"#")
				Мои_Деньги -= 75
				Мои_пункты[1][0] = 3 # Блокировка на 4 хода
			# Ледяной шар
			elif Global_Выбор == 2:
				Дефолт = Снаряд_катапульты(80,"B")
				Мои_Деньги -= 80
				Мои_пункты[1][1] = 5 # Блокировка на 5 хода

			# Огненный шар
			elif Global_Выбор == 3:
				Дефолт = Снаряд_катапульты(120,"R")
				Мои_Деньги -= 100
				Мои_пункты[1][2] = 7 # Блокировка на 6 ходов

			if Ходит_Л:
				Снаряд_L = Дефолт
			else:
				Снаряд_R = Дефолт
			
			Катапульты_хитбоксы()
			print_zamok()
			time.sleep(1)
			Выстрел_катапульты()
			time.sleep(1)

		# Войны
		elif Перемещение_в_меню == 2:
			# Магический воин
			if Global_Выбор == 1:
				Добавить_война(Ходит_Л,1)
				Мои_Деньги -= 25
			# Тяжелый пехотинец
			elif Global_Выбор == 2:
				Добавить_война(Ходит_Л,2)
				Мои_Деньги -= 50
				Мои_пункты[2][1] = 3 # Блокировка на 2 хода 
			Войны_Хитбоксы()
			print_zamok()
			time.sleep(2)
		
		if Ходит_Л:
			Монеты_Л = Мои_Деньги
			Перезарядка_пунктов_L = Мои_пункты
		else:
			Монеты_П = Мои_Деньги
			Перезарядка_пунктов_R = Мои_пункты

	Перемещение_в_меню = 0
	Global_Выбор = 0



# Прочие функции

def Ввод_через_буфер():
	# Если в буфере клавиатуры есть символ
	if msvcrt.kbhit() != 0:
		global INPUT

		while msvcrt.kbhit():
			INPUT = msvcrt.getch()


		if INPUT == b"0":
			INPUT = "0"
		elif INPUT == b"1":
			INPUT = "1"
		elif INPUT == b"2":
			INPUT = "2"
		elif INPUT == b"3":
			INPUT = "3"
		elif INPUT == b"4":
			INPUT = "4"
		elif INPUT == b"5":
			INPUT = "5"
		elif INPUT == b"\r":
			INPUT = ""
		else:
			INPUT = None
	

def Процент_от_числа_int(a,b):
	return math.trunc((a * 100) / b)

def Секунда_Сейчас():
	return int(datetime.datetime.today().strftime("%S"))

def sigmoid(x):
	return 1 / (1 + np.exp(-x))

def Сменить_ход():
	global Ходит_Л, Ход, Смена_ветра, Ветер_Направо, Example, Перезарядка_пунктов_L, Перезарядка_пунктов_R, Новый_Баф, Баф_Л, Баф_П
	Example = None # Обнуляем переменную для звука

	# Смена ветра
	Ход += 1
	if Смена_ветра == 0:
		Смена_ветра = random.randint(2,6)
		Ветер_Направо = not Ветер_Направо
		Флаги_хитбоксы()
	else:
		Смена_ветра -= 1

	# Перезарядка пунктов
	for i in Перезарядка_пунктов_L:
		for j in range(len(i)):
			i[j] -= 1 if i[j] != 0 else 0

	for i in Перезарядка_пунктов_R:
		for j in range(len(i)):
			i[j] -= 1 if i[j] != 0 else 0

	# Бафы
	# 	Спавн
	if "U" not in Игровое_поле:
		Новый_Баф -= 1
		if Новый_Баф <= 0:
			Новый_Баф = random.randint(10, 15)
			Спавн_бафа()
	# 	Просчет
	if Баф_Л[0] != 0:
		Баф_Л[0] -= 1
	if Баф_П[0] != 0:
		Баф_П[0] -= 1

			

	

	Ходит_Л = not Ходит_Л



# Функции связанные с ИИ
def ИИ():
	# Функция возвращает цифру от 0 до 3
	#           0  1  2  3  
	Выбор_ии = [0, 0, 0, 0]

	# 0 - Починить замок 
	# 1 - Зарядить катапульту
	# 2 - Воин
	# 3 - Огонь у замка

	'''
	def Веса_ИИ(Тренеровочные_данные, Ожидаемый_результат):
		np.random.seed(1)

		Случайные_веса = 2 * np.random.random((len(Тренеровочные_данные[0]), 1)) - 1

		# Метод обратного распостранения

		for i in range(20000):
			Входной_слой = Тренеровочные_данные
			Ответ = sigmoid(np.dot(Входной_слой, Случайные_веса))

			ошибки = Ожидаемый_результат - Ответ
			отрегулированные_веса = np.dot(Входной_слой.T, ошибки * (Ответ * (1 - Ответ)))

			Случайные_веса += отрегулированные_веса

		return Случайные_веса

	
	Тренеровочные_данные = np.array([[1,1],
									[0,1],
									[1,0]])

	Ожидаемый_результат = np.array([[0, 0, 1]]).T
	'''
	#Веса_Войны = Веса_ИИ(Тренеровочные_данные, Ожидаемый_результат)
	#print(ИИ_chek(np.array([1, 1]), Веса_Войны), "\n", Веса_Войны)

	def ИИ_chek(Данные, Веса):
		return sigmoid(np.dot(Данные, Веса))

	Деньги_противника = Монеты_Л; Мои_Деньги = Монеты_П
	Мои_хп = Хп_П; Противник_хп = Хп_Л

	# Обучаем ситуациям когда надо чинить замок

	#1. a(Возможность выстрела катап противника(1 krit else 0))
	#2. b(Мои_хп (1 krit else 0)) 
	#3. c(Расстояние войнов противника до замка (1 krit else 0)) 
	
	# V1.0 Без учета перезарядки пунктов
	# Преобразование данных в 1 и 0

	# 1
	if (not Ветер_Направо and Смена_ветра == 1) or (Ветер_Направо and Смена_ветра > 1) or (not Ветер_Направо and len(Войны_П) == 0):
		if Монеты_Л >= 25:
			a = 1 if Процент_от_числа_int(Хп_П, Point) <= 35 else 0
		else:
			a = 0
	else:
		a = 0
	# 2
	#b = 1 if Процент_от_числа_int(Мои_хп, Point) <= 35 else 0
	b = 1 if Мои_хп <= 240 else 0
	# 3
	c = 0
	if len(Войны_Л) == 0:
		c = 0
	else:
		# Поиск война
		for i in range(477, 465, -1):
			# Воин найден
			if coord_противник(i) and Мои_хп >= 240:

				# Узнаем его скорость
				for j in range(len(Войны_Л)):
					if Войны_Л[j].coord == i:
						c = 1 if Войны_Л[j].coord + Войны_Л[j].V >= 477 else 0
						break
				break

	Веса_Починка = [[8.74417046], [8.74417046], [-13.20200264]]

	Выбор_ии[0] = [[0]] if Мои_Деньги < 100 or Перезарядка_пунктов_R[0][0] != 0 else ИИ_chek(np.array([a, b, c]), Веса_Починка)

	# Обучаем ситуация когда нужно стрелять из катапульты
	# ИИ определит стоит ли стрелять, а каким именно снарядом отвечает 2 система, которая накапливает лучшие варианты во время сбора информации

	global Координата_катапульты_ии, Снаряд_ИИ

	#            1  2  3
	Снаряд_ИИ = [0, 0, 0]
	# 1 - Камень
	# 2 - Лед
	# 3 - Огонь


	if Ветер_Направо:
		#1. a(Стоят ли 2 война противника рядом) 1 - yes 0 - no
		#2. b(Xp Противника) 1 - low 0 - hight
		#3. c(Противник может забрать бонус) 1 - yes 0 - no
		#4. d(Стоит ли подождать смены ветра если можно убить моментально) (1) - Стоит (0) - Нет
		a = 0; d = 0

		Веса_Катапульта = [[5.7816576], [5.7816576], [3.7816576], [-20.58652463]]

		# Приоритет (3) -> (1) -> (2) -> (4)

		# 3
		if "U" not in Игровое_поле:
			c = 0
		else:
			if len(Войны_Л) == 0:
				c = 0
			else:
				for i in range(466, 478):
					if Игровое_поле[i] == "U":
						coord_u = i

				Filter_воины = list(filter(lambda x: x.coord < coord_u, Войны_Л))
				
				c = 0
				for i in Filter_воины:
					if i.coord + i.V >= coord_u:
						# Если бонус труднодоступен
						if coord_u < 472 and len(Войны_П) == 0:
							c = 0
						else:

							if Мои_Деньги >= 75 and Перезарядка_пунктов_R[1][0] == 0 and i.hp <= 5:
								Снаряд_ИИ = [1, 0, 0]
								c = 1
								Координата_катапульты_ии = i.coord
							elif Мои_Деньги >= 80 and Перезарядка_пунктов_R[1][1] == 0:
								if len(Войны_П) != 0:
									if Войны_П[0].coord - 2 * (Войны_П[0].V) <= coord_u:
										Снаряд_ИИ = [0, 1, 0]
										c = 1
										Координата_катапульты_ии = i.coord
						break

		# 1
		if len(Войны_Л) >= 2:
			for i in range(len(Войны_Л) - 1, 0, -1):
				if Войны_Л[i].coord - 1 == Войны_Л[i - 1].coord and Войны_Л[i - 1].status == "Norm":
					a = 1

					if Войны_Л[i].coord >= 472:
						# Лед
						if Мои_Деньги >= 75:
							Снаряд_ИИ = [1, 0, 0] if Перезарядка_пунктов_R[1][1] == 0 else [0, 0, 0]
							Координата_катапульты_ии = Войны_Л[i - 1].coord if Войны_Л[i - 1].hp > Войны_Л[i].hp else Войны_Л[i].coord

					# Если у нас есть войны которые могут сделать моментальное убийство
					elif len(Войны_П) != 0:
						if Войны_П[0].coord - 2 * (Войны_П[0].V) <= Войны_Л[i].coord:
							# Лед
							if Мои_Деньги >= 80:
								Снаряд_ИИ = [0, 1, 0] if Перезарядка_пунктов_R[1][1] == 0 else [0, 0, 0]
								Координата_катапульты_ии = Войны_Л[i - 1].coord
					else:
						a = 0

					break

		# 2
		b = 1 if Процент_от_числа_int(Хп_П, Point) <= 15 and len(Войны_Л) == 0 else 0

		# 4
		win = False # Переменная - Исключение, Самый главный приоритет
		if Хп_Л <= 180:

			if len(Войны_Л) == 0:

				if Хп_Л <= 180 and Мои_Деньги >= 100 and Перезарядка_пунктов_R[1][2] == 0:
					a = 1
					Снаряд_ИИ = [0, 0, 1]
					win = True
				elif Хп_Л <= 120 and Мои_Деньги >= 80 and Перезарядка_пунктов_R[1][1] == 0:
					a = 1
					Снаряд_ИИ = [0, 1, 0]
					win = True
				elif Хп_Л <= 90 and Мои_Деньги >= 75 and Перезарядка_пунктов_R[1][0] == 0:
					a = 1
					Снаряд_ИИ = [1, 0, 0]
					win = True

			else:
				d = 1
			#d = 0 if len(Войны_Л) == 0 else 1

		Выбор_ии[1] = [[0]] if Мои_Деньги < 75 or Снаряд_ИИ == [0, 0, 0] else ИИ_chek(np.array([a, b, c, d]), Веса_Катапульта)

		# Исключение
		if not win:

			if len(Войны_Л) == 0 and Мои_хп > 240:
				Снаряд_ИИ = [0, 0, 0]
				if Мои_Деньги >= 100:
					Снаряд_ИИ = [0, 0, 1]  if Перезарядка_пунктов_R[1][2] == 0 else [0, 0, 0]
				if Мои_Деньги >= 80 and Снаряд_ИИ == [0, 0, 0]:
					Снаряд_ИИ = [0, 1, 0]  if Перезарядка_пунктов_R[1][1] == 0 else [0, 0, 0]
				if Мои_Деньги >= 75 and Снаряд_ИИ == [0, 0, 0]:
					Снаряд_ИИ = [1, 0, 0]  if Перезарядка_пунктов_R[1][0] == 0 else [0, 0, 0]

				if Снаряд_ИИ != [0, 0, 0]:
					Выбор_ии[1] = [[1]]

		# Приоритет победного выстрела
		if win:
			Выбор_ии[1] = [[100]]



	else:
		

		Веса_Катапульта = [[ 9.65155245], [-4.72306978]]

		# По дефолту, если все хорошо, то стреляем камнем
		if сложность == 1:
			Снаряд_ИИ = [0, 0, 0]
		else:
			Снаряд_ИИ = [1, 0, 0] if Перезарядка_пунктов_R[1][0] == 0 else [0, 0, 0]

		# Если сложный то бьем сильно
		if сложность == 1:
			if Мои_Деньги >= 100 and Перезарядка_пунктов_R[1][2] == 0:
				Снаряд_ИИ = [0, 0, 1]
			elif Мои_Деньги >= 80 and Перезарядка_пунктов_R[1][1] == 0:
				Снаряд_ИИ = [0, 1, 0]
			elif Мои_Деньги >= 75 and Перезарядка_пунктов_R[1][0] == 0:
				Снаряд_ИИ = [1, 0, 0]

		#1. a(xp противника) 1 - yes 0 - no

		win = False # Переменная - Исключение, Самый главный приоритет

		a = 0

		if Хп_Л <= 180 and Мои_Деньги >= 100 and Перезарядка_пунктов_R[1][2] == 0:
			a = 1
			Снаряд_ИИ = [0, 0, 1]
			win = True
		elif Хп_Л <= 120 and Мои_Деньги >= 80 and Перезарядка_пунктов_R[1][1] == 0:
			a = 1
			Снаряд_ИИ = [0, 1, 0]
			win = True
		elif Хп_Л <= 90 and Мои_Деньги >= 75 and Перезарядка_пунктов_R[1][0] == 0:
			a = 1
			Снаряд_ИИ = [1, 0, 0]
			win = True

		#2. b(ситуация на поле) 1 - no 0 - norm
		#(Norm если 472 и более не заняты противником)
		b = 0
		for i in range(472, 478):
			if Игровое_поле[i] == Цвет_флага_Л:
				b = 1
				break

		Выбор_ии[1] = [[0]] if Мои_Деньги < 75 or Снаряд_ИИ == [0, 0, 0] else ИИ_chek(np.array([a, b]), Веса_Катапульта)

		# Приоритет победного выстрела
		if win:
			Выбор_ии[1] = [[100]]

		# Исключение Копируем со соложного
		if Мои_Деньги >= 75 and a == 0 and b == 0:

			if сложность == 1:
				# Самый сильный
				if Мои_Деньги >= 100 and Перезарядка_пунктов_R[1][2] == 0:
					Снаряд_ИИ = [0, 0, 1]
					Выбор_ии[1] = [[0.99993568]]
				elif Мои_Деньги >= 80 and Перезарядка_пунктов_R[1][1] == 0:
					Снаряд_ИИ = [0, 1, 0]
					Выбор_ии[1] = [[0.99993568]]
				elif Мои_Деньги >= 75 and Перезарядка_пунктов_R[1][0] == 0:
					Снаряд_ИИ = [1, 0, 0]
					Выбор_ии[1] = [[0.99993568]]
			else:
				# Камень если легко
				if Мои_Деньги >= 75 and Перезарядка_пунктов_R[1][0] == 0:
					Снаряд_ИИ = [1, 0, 0]
					Выбор_ии[1] = [[0.99993568]]

	

	# Обучаем ситуациям когда нужно выпускать война
	# Если сложность 1 - то учим ии что по дефолту мы должны доминировать, а если 0, то учим сохранять баланс
	# Разброс баланса на лдегкой сложности 1-3 на сложной 8-10


	#1. a(Баланс) 1 - Баланс не в нашу сторону. 0 - В нашу
	#2. b(Катапульта может хорошо зарешать) 1 - Да. 0 - нет
	#3. c(Магического огня нету и есть возможность штурма замка вражеским войском) 1 - Да. 0 - Нет

	Веса_Войны = [[4.72374121], [-9.65290992], [4.72374121]]

	global Номер_война_ии

	Баланс = sum([i.hp for i in Войны_П]) - sum([i.hp for i in Войны_Л])


	if сложность == 1:
		Temp = 8
	else:
		Temp = -3

	# a
	if Баланс < Temp and Мои_Деньги >= 25 and Игровое_поле[477] == " ":
		a = 1

		if Ветер_Направо:
			Номер_война_ии = 1
		elif not Ветер_Направо and Мои_Деньги >= 50 and Перезарядка_пунктов_R[2][1] == 0:
			Номер_война_ии = 2
		else:
			if len(Войны_П) != 0 and Мои_Деньги >= 50 and Перезарядка_пунктов_R[2][1] == 0:
				Номер_война_ии = 2
			else:
				Номер_война_ии = 1

	else:
		a = 0

	#Перезарядка_пунктов_R = [[0,0,0,0], [0,0,0], [0,0]]

	# b
	if len(Войны_Л) != 0:
		b = 0
		for i in range(472, 478):
			if Игровое_поле[i] == Цвет_флага_Л and Игровое_поле[i + 1] == Цвет_флага_Л and Мои_Деньги >= 80: # Не совсем точно
				b = 1
				break
	else:
		b = 1

	# c
	c = 0
	if len(Войны_Л) != 0:

		if Войны_Л[-1].coord + Войны_Л[-1].V >= 477:

			c = 1

			if Мои_Деньги >= 50:
				Номер_война_ии = 2
			elif Мои_Деньги >= 25:
				Номер_война_ии = 1
			else:
				c = 0


	Выбор_ии[2] = [[0]] if Игровое_поле[477] != " " else ИИ_chek(np.array([a, b, c]), Веса_Войны)

	


	# Ситуация с огнем слишком простая (ИИ не нужен)
	a = [[0]]
	if Перезарядка_пунктов_R[0][3] == 0 and Мои_Деньги >= 40:
		for i in range(477, 474, -1):
			if Игровое_поле[i] == Цвет_флага_П:
				break
			elif Игровое_поле[i] == Цвет_флага_Л and int(Игровое_поле[i + 41]) <= 3:
				a = [[2]]


	Выбор_ии[3] = a


	# Проверка выбора
	maximym = [0, Выбор_ии[0][0]]
	for i in range(len(Выбор_ии)):
		if Выбор_ии[i][0] > maximym[1]:
			maximym = [i, Выбор_ии[i][0]]

	if maximym[1] == 0.5 or maximym[1] == 0:
		maximym = [-1, 0]

	if maximym[0] == 0 and (Перезарядка_пунктов_R[0][0] != 0 or Мои_Деньги < 100):
		maximym = [-1, 0]

	#print(Перезарядка_пунктов_R)
	#print(Снаряд_ИИ)
	#print(Выбор_ии, Монеты_П)
	#input()

	return maximym[0]

	# cd D:/Python & D: & python Замки.py


def Ход_ИИ(Выбор_ии):
	global Монеты_П, Снаряд_R, Перезарядка_пунктов_R

	# Починка замка
	if Выбор_ии == 0:
		Починить_замок("R")
		time.sleep(3)
		Монеты_П -= 100
		Перезарядка_пунктов_R[0][0] = 3 # Блокировка на 4 хода

	# Катапульта
	elif Выбор_ии == 1:
		# Огненный шар
		if Снаряд_ИИ[2] == 1:
			Снаряд_R = Снаряд_катапульты(120, "R")
			Монеты_П -= 100
			Перезарядка_пунктов_R[1][2] = 7
		# Ледяной шар
		elif Снаряд_ИИ[1] == 1:
			Снаряд_R = Снаряд_катапульты(80, "B")
			Монеты_П -= 80
			Перезарядка_пунктов_R[1][1] = 5
		# Каменный шар
		else:
			Снаряд_R = Снаряд_катапульты(60, "#")
			Монеты_П -= 75
			Перезарядка_пунктов_R[1][0] = 3
		
		# Выстрел зависит от ветра
		if not Ветер_Направо:
			Полет_в_замок(0, Снаряд_R.skin, True)
		else:
			Полет_в_война(18, Снаряд_R.skin, True, Координата_катапульты_ии)

	# Войны
	elif Выбор_ии == 2:
		Добавить_война(False, Номер_война_ии)
		Войны_Хитбоксы()

		if Номер_война_ии == 2:
			Перезарядка_пунктов_R[2][1] = 3

	# Магический огонь
	elif Выбор_ии == 3:
		Огонь_у_замка(False)
		Перезарядка_пунктов_R[0][3] = 6

def coord_противник(x):
	# Возвращает True если на этой координате есть противник
	status = False
	if len(Войны_Л) != 0:
		for i in Войны_Л:
			if i.coord == x:
				return True
	return status
	


# Создаем все необходимые классы объектов
class Воин():

	def __init__ (self, hp, coord, status, effect, V, damage, i_status, Баф, Name):
		# hp - здоровье
		self.hp = hp
		# coord - Позиция на игровом поле
		self.coord = coord
		# status - Заморожен либо под огнем (Norm Freeze Fire)
		self.status = status
		# какие эффекты на войне
		self.effect = effect
		# Скорость перемещения в клетках
		self.V = V
		# Урон
		self.damage = damage
		# Счетчик status (Через сколько ходов статус станет Norm)
		self.i_status = i_status
		# Баф
		self.Баф = Баф
		# Имя война
		self.Name = Name

class Снаряд_катапульты():

	def __init__ (self, damage, skin):
		# damage - Урон
		self.damage = damage
		# skin - как выглядит снаряд
		self.skin = skin
		

# Создаем игровое поле

# Игровое поле 40x13
Игровое_поле = []
for i in range(533):
	if i < 492:
		Игровое_поле.append(" ")
	else:
		Игровое_поле.append("#")

# Отступы для поля
OTSTYP = [i for i in range(520) if i % 41 == 0]

# Рисуем замки 
Координаты_Замков = [506, 465, 424, 383,             # Левая стена
					 519, 478, 437 , 396,             # Правая стена
					 46, 87, 128, 127, 170, 169, 168, 167, 206, 209, 210, # Левый замок
					 251, 250, 293, 292, 291, 290, 247,248, 253,254, 213, #
					 334, 333, 332, 331, 374, 373, 415, 414, 457, 456, 455, 454, #
					 422, 421, 380,#л_кат
					 439,440, 399  #п_кат
]


# Добавляем координаты правого замка
for i in range(8,42):
	if i > 9:
		Координаты_Замков.append(Координаты_Замков[i]+32)
	else:
		Координаты_Замков.append(Координаты_Замков[i]+31)


# Хитбоксы замков строим по координатам

for i in range(len(Координаты_Замков)):
	Игровое_поле[Координаты_Замков[i]] = "#"


#Фиолетовая обводка для замков (Для красоты)
FIOLET = [288,289, 294, 295, 330, 335, 372, 375, 413, 416, 453, 458] # Левый замок

# Правый
for i in range(len(FIOLET)):
	FIOLET.append(FIOLET[i]+32)

# Левая катапульта
FIOLET.append(464)
FIOLET.append(461)
# Правая
FIOLET.append(479)
FIOLET.append(482)

# Рисуем Хитбоксы для фсех фиолетовых поверхностей

for i in range(len(FIOLET)):
	Игровое_поле[FIOLET[i]] = "M"



# Моментальный вызов необходимых функций и списков
Снаряд_L = Снаряд_катапульты(0, " ")
Снаряд_R = Снаряд_катапульты(0, " ")

Катапульты_хитбоксы()
Флаги_хитбоксы()


############ Стенд для проверок всего
#Ходит_Л = True
#Добавить_война(not Ходит_Л, 1)
#Добавить_война(Ходит_Л, 1)
#Войны_Л.append(Воин(3, Образец_война_легкая_пехота_R[1] - 1 - 3, Образец_война_легкая_пехота_L[2], Образец_война_легкая_пехота_L[3], Образец_война_легкая_пехота_L[4], Образец_война_легкая_пехота_L[5], Образец_война_легкая_пехота_L[6], Образец_война_легкая_пехота_L[7], Образец_война_легкая_пехота_L[8]))
#Войны_Л.append(Воин(Образец_война_легкая_пехота_L[0], Образец_война_легкая_пехота_R[1] - 1 - 6, Образец_война_легкая_пехота_L[2], Образец_война_легкая_пехота_L[3], Образец_война_легкая_пехота_L[4], Образец_война_легкая_пехота_L[5], Образец_война_легкая_пехота_L[6], Образец_война_легкая_пехота_L[7], Образец_война_легкая_пехота_L[8]))
#Войны_П.append(Воин(Образец_война_легкая_пехота_L[0] , Образец_война_легкая_пехота_R[1] - 1, Образец_война_легкая_пехота_L[2], Образец_война_легкая_пехота_L[3], Образец_война_легкая_пехота_L[4], Образец_война_легкая_пехота_L[5], Образец_война_легкая_пехота_L[6], Образец_война_легкая_пехота_L[7], Образец_война_легкая_пехота_L[8]))
#Войны_П.append(Воин(Образец_война_легкая_пехота_L[0], Образец_война_легкая_пехота_R[1] - 6, Образец_война_легкая_пехота_L[2], Образец_война_легкая_пехота_L[3], Образец_война_легкая_пехота_L[4], Образец_война_легкая_пехота_L[5], Образец_война_легкая_пехота_L[6], Образец_война_легкая_пехота_L[7], Образец_война_легкая_пехота_L[8]))
#Войны_Хитбоксы()
#Ходит_Л = False
#Решение_примера = False
#Новый_Баф = 0
#Сменить_ход()
#Ходит_Л = not Ходит_Л
#Хп_П = 100
#Хп_Л = Point
Монеты_Л = 500
Монеты_П = 500
#Игровое_поле[472] = "U"
#Игра_против_ИИ = True
############

'''
for i in range(5):
	Чат = "Игра через : " + str(5 - i)
	print_zamok()
	Развивание_флагов()
	Чат = ""
	time.sleep(1)
'''


# Главный цикл
# cd D:/Python & D: & python Замки.py
while Win_L == None:
	# Для снижения нагрузки на процессор
	time.sleep(0.01)


	# Обновление игры 1 FPS
	if Секунда_Сейчас_ЗАМКИ != Секунда_Сейчас():
		Секунда_Сейчас_ЗАМКИ = Секунда_Сейчас()

		Развивание_флагов()
		print_zamok()

		# Искуственный интелект
		if Игра_против_ИИ and not Ходит_Л:

			if сложность == 1:
				Монеты_П += random.randint(25, 50)
				Звук_kush()
			else:
				if random.randint(1, 10) <= 8:
					Монеты_П += random.randint(25, 50)
					Звук_kush()
				else:
					Звук_NePa()

			time.sleep(0.5)

			Ход_ИИ(ИИ())
			Перемещение_и_атака_юнитов()
			Сменить_ход()
			TIME_Z = 7
		

		else:
			# Вопрос о решении примера
			if Решение_примера:
				if Создание_примера:
					time.sleep(1)
					Создание_примера = False
					Пример_сейчас = Генерация_примера(сложность)
					Разброс_ответа = Разброс_ответа_1(Пример_сейчас)

				if TIME_Z != -1:
					print_пример(Пример_сейчас, Разброс_ответа)
					TIME_Z -= 1
					Think()

				else:
					TIME_Z += 1
					Решение_примера = False
					INPUT = 0
					Перемещение_в_меню = 0
					print_пример(Пример_сейчас, Разброс_ответа, Пример_сейчас[3])
					TIME_Z = 6
					
					
			else:
				print_menu()
				TIME_Z -= 1
				Make()

				if TIME_Z == -1:
					TIME_Z += 1
					Выбор_игрока()
					Решение_примера = True
					Создание_примера = True
					Перемещение_и_атака_юнитов()
					time.sleep(1)
					INPUT = None
					TIME_Z = 7
					Сменить_ход()
					
			if INPUT == "5":
				exit()


print("Победил левый") if Win_L else print("Победил правый")
